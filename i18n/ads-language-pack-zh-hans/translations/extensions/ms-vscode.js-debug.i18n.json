{
	"": [
		"--------------------------------------------------------------------------------------------",
		"Copyright (c) Microsoft Corporation. All rights reserved.",
		"Licensed under the MIT License. See License.txt in the project root for license information.",
		"--------------------------------------------------------------------------------------------",
		"Do not edit this file. It is machine generated."
	],
	"version": "1.0.0",
	"contents": {
		"package": {
			"add.browser.breakpoint": "添加浏览器断点",
			"attach.node.process": "附加到 Node 进程",
			"base.cascadeTerminateToConfigurations.label": "当终止此调试会话时，也将停止的调试会话的列表。",
			"browser.address.description": "调试的浏览器正在侦听的 IP 地址或主机名。",
			"browser.attach.port.description": "用于远程调试浏览器的端口，在启动浏览器时通过 `--remote-debugging-port` 指定。",
			"browser.baseUrl.description": "用于解析路径 baseUrl 的基本 URL。 将 URL 映射到磁盘上的文件时，将修剪 baseURL。 默认为启动 URL 域。",
			"browser.browserAttachLocation.description": "强制在一个位置连接浏览器。在远程工作区中(例如通过 ssh 或 WSL)，这可用于在远程计算机上而不是在本地连接浏览器。",
			"browser.browserLaunchLocation.description": "强制在一个位置启动浏览器。在远程工作区中(例如通过 ssh 或 WSL)，这可用于在远程计算机上而不是在本地打开浏览器。",
			"browser.cleanUp.description": "调试会话完成后的清理操作:“仅关闭正在调试的选项卡”和“关闭整个浏览器”。",
			"browser.cwd.description": "运行时可执行文件的可选工作目录。",
			"browser.disableNetworkCache.description": "控制是否跳过每个请求的网络缓存",
			"browser.env.description": "浏览器的环境键/值对的可选字典。",
			"browser.file.description": "要在浏览器中打开的本地 HTML 文件",
			"browser.includeDefaultArgs.description": "启动中是否包括默认浏览器启动参数(以禁用可能使调试更加困难的功能)。",
			"browser.inspectUri.description": "用于重写 inspectUri 的格式: 这是一个模板字符串，可插入 \"{curlyBraces}\" 中的键。可用的键包括:\r\n - \"url.*\" 是正在运行的应用程序的解析地址，例如 \"{url.port}\" 和 \"{url.hostname}\"\r\n - \"port\" 是 Chrome 正在侦听的调试端口。\r\n - \"browserInspectUri\" 是启动的浏览器上的检查器 URI\r\n - \"browserInspectUriPath\" 是启动的浏览器上的检查器 URI 的路径部分(例如 \"/devtools/browser/e9ec0098-306e-472a-8133-5e42488929c2\")\r\n - \"wsProtocol\" 是提示的 websocket 协议。如果原始 URL 为 \"https\"，则设置为 \"wss\"，否则为 \"ws\"。\r\n",
			"browser.launch.port.description": "浏览器侦听的端口。默认值为“0”，这将导致浏览器通过管道进行调试，这通常更安全，除非需要从其他工具连接到浏览器，否则应选择该值。",
			"browser.pathMapping.description": "将 URL/路径映射到本地文件夹，以将浏览器中的脚本解析为磁盘上的脚本",
			"browser.perScriptSourcemaps.description": "是否使用包含源文件基本名称的唯一源映射单独加载脚本。处理大量小型脚本时，可以设置此项来优化源映射处理。如果设置为“自动”，将在可以检测已知用例时进行检测。",
			"browser.profileStartup.description": "如果为 true，则将在进程启动后立即开始分析",
			"browser.restart": "是否在浏览器连接关闭时重新连接",
			"browser.revealPage": "焦点选项卡",
			"browser.runtimeArgs.description": "传递给运行时可执行文件的可选参数。",
			"browser.runtimeExecutable.description": "\"canary\"、\"stable\"、\"custom\" 或浏览器可执行文件的路径。 Custom 表示自定义包装器、自定义生成或 CHROME_PATH 环境变量。",
			"browser.runtimeExecutable.edge.description": "\"canary\"、\"stable\"、\"dev'\"、\"custom\" 或浏览器可执行文件的路径。custom 表示自定义包装器、自定义生成或 EDGE_PATH 环境变量。",
			"browser.server.description": "配置要启动的 Web 服务器。采用与 \"node\" 启动任务相同的配置。",
			"browser.skipFiles.description": "文件或文件夹名称，或者路径 glob 的数组，在调试时跳过。",
			"browser.smartStep.description": "自动单步运行源映射文件中未映射的行。例如，向下编译异步/等待或其他功能时，TypeScript 自动生成的代码。",
			"browser.sourceMapPathOverrides.description": "一组用于重写源映射中所述的源文件位置的映射，映射到磁盘上的相应位置。有关详细信息，请参见自述文件。",
			"browser.sourceMaps.description": "使用 JavaScript 源映射(如存在)。",
			"browser.targetSelection": "是附加到与 URL 筛选器匹配的所有目标(“自动”)还是要求选择一个(“选择”)。",
			"browser.timeout.description": "重试此毫秒数以连接到浏览器。默认值为 10000 毫秒。",
			"browser.url.description": "将搜索具有此确切网址的标签并附加到该标签(若找到)",
			"browser.urlFilter.description": "将使用此 URL 搜索页面，找到后将连接到该页面。可使用 * 通配符。",
			"browser.userDataDir.description": "默认情况下，浏览器在临时文件夹中使用单独的用户配置文件启动。使用此选项可以覆盖它。设置为 false 以使用默认用户配置文件启动。",
			"browser.vueComponentPaths": "用于查找 \"*.vue\" 组件的文件 glob 模式的列表。默认搜索整个工作区。需要指定此项，因为 Vue 的源映射需要在 Vue CLI 4 中进行额外查找。可通过将此项设置为空数组来禁用此特殊处理。",
			"browser.webRoot.description": "此设置指定 Web 服务器根的工作区绝对路径。用于将 `/app.js` 等路径解析为磁盘上的文件。pathMapping 的速记方式为 \"/\"",
			"chrome.attach.description": "附加到已处于调试模式的 Chrome 实例",
			"chrome.attach.label": "Chrome: 附加",
			"chrome.label": "Chrome",
			"chrome.launch.description": "启动 Chrome 以调试 URL",
			"chrome.launch.label": "Chrome: 启动",
			"configuration.autoAttachMode": "配置在 \"#debug.node.autoAttach#\" 处于启用状态时自动附加和调试的进程。无论此设置如何，都始终附加到启动的带有 \"--inspect\" 标志的节点进程。",
			"configuration.autoAttachMode.always": "自动附加到终端中启动的每个 Node.js 进程。",
			"configuration.autoAttachMode.disabled": "自动附加被禁用，且不在状态栏中显示。",
			"configuration.autoAttachMode.explicit": "仅在给定 \"--inspect\" 时自动附加。",
			"configuration.autoAttachMode.smart": "运行不在 node_modules 文件夹中的脚本时自动附加。",
			"configuration.autoAttachSmartPatterns": "配置 glob 模式，以确定何时附加智能 `#debug.javascript.autoAttachFilter#` 模式。`$KNOWN_TOOLS$` 被替换为常见测试和代码运行器的名称的列表。[在 VS Code 文档中阅读更多内容](https://code.visualstudio.com/docs/nodejs/nodejs-debugging#_auto-attach-smart-patterns)。",
			"configuration.autoExpandGetters": "配置是否自动扩展属性 getter。如果为 false，getter 将显示为 `get propertyName`，并且仅在单击时才进行评估。",
			"configuration.automaticallyTunnelRemoteServer": "调试远程 Web 应用时，配置是否自动将远程服务器通过隧道传输到本地计算机。",
			"configuration.breakOnConditionalError": "当条件断点引发错误时是否停止。请注意: launch.json `type` 必须带有 \"pwa-\" 前缀才能使用它，例如 \"pwa-node\"。",
			"configuration.debugByLinkOptions": "调试时从调试终端内部单击链接使用的选项。可设置为\"false\"以禁用此行为。",
			"configuration.defaultRuntimeExecutables": "用于启动配置的默认 \"runtimeExecutable\" (如果未指定)。这可用于配置 Node.js 或浏览器安装项的自定义路径。",
			"configuration.npmScriptLensLocation": "在 npm 脚本中应显示“运行”和“调试”代码的位置。 它可以在脚本部分的“全部”、脚本、脚本部分的“顶部”或“从不”上面。",
			"configuration.pickAndAttachOptions": "通过 `Debug: Attach to Node.js Process` 命令调试进程时使用的默认选项",
			"configuration.resourceRequestOptions": "在调试器中加载资源(如源映射)时可使用的请求选项。例如，如果你的源映射需要身份验证或使用自签名证书，则可能需要配置此设置。选项用于创建使用 [`got`](https://github.com/sindresorhus/got) 库的请求。\r\n\r\n可通过传递 `{ \"https\": { \"rejectUnauthorized\": false } }` 来实现禁用证书验证的常见情况。",
			"configuration.suggestPrettyPrinting": "是否建议在单步执行时将看起来被压缩的 JavaScript 代码美观打印。",
			"configuration.terminalOptions": "JavaScript 调试终端和 npm 脚本的默认启动选项。",
			"configuration.unmapMissingSources": "配置是否会自动取消映射无法读取源文件的源映射文件。如果这是 false (默认)，系统会显示提示。",
			"configuration.usePreview": "为 Node.js 和 Chrome 使用新的预览版 JavaScript 调试器。",
			"createDiagnostics.label": "创建当前会话的诊断信息",
			"customDescriptionGenerator.description": "自定义调试程序为对象(本地变量等)显示的文本说明。示例:\r\n      1. this.toString() // 将调用 toString 来打印所有对象\r\n      2. this.customDescription ? this.customDescription() : defaultValue // 如果未返回 defaultValue，则使用 customDescription 方法(若可用)\r\n      3. function (def) { return this.customDescription ? this.customDescription() : def } // 如果未返回 defaultValue，则使用 customDescription 方法(若可用)\r\n      ",
			"customPropertiesGenerator.description": "自定义为调试程序中的对象显示的属性(本地变量等)。示例:\r\n    1. { ...this, extraProperty: '12345' } // 向所有对象添加 extraProperty 12345\r\n    2. this.customProperties ? this.customProperties() : this // 如果不使用此(默认属性)中的属性，请使用 customProperties 方法(若可用)\r\n    3. function () { return this.customProperties ? this.customProperties() : this } // 如果不返回默认属性，请使用 customDescription 方法(若可用)\r\n\r\n    已弃用: 这是此功能的临时实现，直到我们有时间按此处所示方法实现它为止: https://github.com/microsoft/vscode/issues/102181",
			"debug.npm.edit": "编辑 package.json",
			"debug.npm.noScripts": "在 package.json 中找不到 npm 脚本",
			"debug.npm.noWorkspaceFolder": "需要打开工作区文件夹来调试 npm 脚本。",
			"debug.npm.parseError": "无法读取 {0}: {1}",
			"debug.npm.script": "Debug npm Script",
			"debug.terminal.attach": "附加到 Node.js 终端进程",
			"debug.terminal.label": "创建 JavaScript 调试终端",
			"debug.terminal.program.description": "在启动的终端中运行命令。如果未提供命令，终端将在不启动程序的情况下打开。",
			"debug.terminal.snippet.label": "在调试终端中运行 \"npm start\"",
			"debug.terminal.toggleAuto": "切换终端 Node.js 自动附加",
			"debug.terminal.welcome": "[JavaScript 调试终端](command:extension.js-debug.createDebuggerTerminal)\r\n\r\n可使用 JavaScript 调试终端调试在命令行上运行的 Node.js 进程。",
			"debug.terminal.welcomeWithLink": "[JavaScript 调试终端](command:extension.js-debug.createDebuggerTerminal)\r\n\r\n可使用 JavaScript 调试终端调试在命令行上运行的 Node.js 进程。\r\n\r\n[调试 URL](command:extension.js-debug.debugLink)",
			"debugLink.label": "打开链接",
			"edge.address.description": "调试 Web 视图时，Web 视图正在侦听的 IP 地址或主机名。如果未设置，则自动发现。",
			"edge.attach.description": "附加到已在调试模式下的 Edge 实例",
			"edge.attach.label": "Microsoft Edge: 附加",
			"edge.label": "Edge",
			"edge.launch.description": "启动 Microsoft Edge 以调试 URL",
			"edge.launch.label": "Microsoft Edge: 启动",
			"edge.port.description": "调试 Web 视图时，Web 视图调试程序正在侦听的端口。如果未设置，则自动发现。",
			"edge.useWebView.description": "(仅适用于Edge(Chromium))，如果设置为true，则调试器会将运行时可执行文件视为包含WebView的主机应用程序，以允许您调试WebView脚本内容。",
			"enableContentValidation.description": "切换是否要验证确定磁盘上的文件内容与运行时中加载的内容相匹配。这在各种情况下都很有用，在一些情况下还是必需操作，但是如果你具有脚本的服务器端转换，则可能会导致出现问题。",
			"errors.timeout": "{0}: {1} 毫秒后超时",
			"extension.description": "用于调试 Node.js 程序和 Chrome 的扩展。",
			"extensionHost.label": "VS Code 扩展开发",
			"extensionHost.launch.config.name": "启动扩展",
			"extensionHost.launch.debugWebWorkerHost": "配置是否应尝试附加到 Web 辅助进程扩展主机。",
			"extensionHost.launch.debugWebviews": "配置是否应尝试附加到已启动的 VS Code 实例中的 Web 视图。**请注意:** 要使其正常工作，当前需要设置 \"webview.experimental.useIframes\": true，并且此功能仅适用于桌面 VS Code。",
			"extensionHost.launch.env.description": "传递给扩展主机的环境变量。",
			"extensionHost.launch.rendererDebugOptions": "附加到呈现器进程时使用的 Chrome 启动选项，具有 \"debugWebviews\" 或 \"debugWebWorkerHost\"。",
			"extensionHost.launch.runtimeExecutable.description": "VS Code 的绝对路径。",
			"extensionHost.launch.stopOnEntry.description": "启动后自动停止扩展主机。",
			"extensionHost.snippet.launch.description": "在调试模式下启动 VS Code 扩展",
			"extensionHost.snippet.launch.label": "VS Code 扩展开发",
			"longPredictionWarning.disable": "不再显示",
			"longPredictionWarning.message": "配置断点需要一段时间。你可通过更新 launch.json 中的 \"outFiles\" 来加快速度。",
			"longPredictionWarning.noFolder": "未打开工作区文件夹。",
			"longPredictionWarning.open": "打开 launch.json",
			"node.address.description": "要调试的进程的 TCP/IP 地址。默认值为 \"localhost\"。",
			"node.attach.attachExistingChildren.description": "是否尝试附加到已生成的子进程。",
			"node.attach.attachSpawnedProcesses.description": "是否在附加过程中设置环境变量以跟踪生成的子级。",
			"node.attach.config.name": "附加",
			"node.attach.continueOnAttach": "如果为 true，我们将自动恢复启动的程序并等待 \"--inspect-brk\"",
			"node.attach.processId.description": "要附加到的进程 ID。",
			"node.attach.restart.description": "如果连接断开，请尝试重新连接到该程序。如果设置为 \"true\"，将始终每秒重试一次。可通过在对象中指定 \"delay\" 和 \"maxAttempts\" 来自定义时间间隔和最大尝试次数。",
			"node.attachSimplePort.description": "如果设置，则通过给定端口附加到进程。Node.js 程序通常不再需要该设置，而且它没法再调试子进程，但在使用 Deno 和 Docker 启动等更复杂的场景中，它可能很有用。如果设置为 0，则将选择随机端口，并自动向启动参数添加 --inspect-brk。",
			"node.console.title": "Node 调试控制台",
			"node.disableOptimisticBPs.description": "请勿在任何文件中设置断点，除非该文件已加载源映射。",
			"node.killBehavior.description": "配置在停止会话时如何终止调试进程。可以是:\r\n\r\n- forceful (default): 强制关闭进程树。在 posix 上发送 SIGKILL，在 Windows 上发送 \"taskkill.exe /F\"。\r\n- polite: 正常关闭进程树。可能出现按此方式关闭后继续运行行为出错的进程的情况。在 posix 上发送 SIGTERM，在 Windows 上发送 \"taskkill.exe\" 但不带 \"/F\" (强制)标志。\r\n- 无: 将不终止。",
			"node.label": "Node.js",
			"node.launch.args.description": "传递给程序的命令行参数。",
			"node.launch.autoAttachChildProcesses.description": "自动将调试器附加到新的子进程。",
			"node.launch.config.name": "启动",
			"node.launch.console.description": "启动调试目标的位置。",
			"node.launch.console.externalTerminal.description": "可通过用户设置来配置的外部终端",
			"node.launch.console.integratedTerminal.description": "VS Code 的集成终端",
			"node.launch.console.internalConsole.description": "VS Code 调试控制台(不支持从程序读取输入)",
			"node.launch.cwd.description": "正在调试程序工作目录的绝对路径。如果已设置 localRoot，则 cwd 将与该值匹配，否则它将回退到 workspaceFolder",
			"node.launch.env.description": "传递到程序的环境变量。`null` 值从环境中删除该变量。",
			"node.launch.envFile.description": "包含环境变量定义的文件的绝对路径。",
			"node.launch.logging": "日志记录配置",
			"node.launch.logging.cdp": "Chrome DevTools 协议消息的日志文件路径",
			"node.launch.logging.dap": "调试适配器协议消息的日志文件的路径",
			"node.launch.outputCapture.description": "捕获输出消息的位置: 如果设置为 `console`，则为默认调试 API，如果设置为 `std`，则为 stdout/stderr 流。",
			"node.launch.program.description": "程序的绝对路径。通过查看 package.json 和打开的文件猜测所生成的值。编辑此属性。",
			"node.launch.restart.description": "如果程序退出时带有非零的退出码，则尝试重启该程序。",
			"node.launch.runtimeArgs.description": "传递给运行时可执行文件的可选参数。",
			"node.launch.runtimeExecutable.description": "要使用的运行时。应为绝对路径或在 PATH 上可用的运行时名称。默认值为 \"node\"。",
			"node.launch.runtimeSourcemapPausePatterns": "手动插入入口点断点的模式列表。在使用不存在或启动前无法检测到的源映射时，这有助于让调试程序设置断点，例如[使用无服务器框架](https://github.com/microsoft/vscode-js-debug/issues/492)。",
			"node.launch.runtimeVersion.description": "要使用的 \"node\" 运行时版本。需要 \"nvm\"。",
			"node.launch.useWSL.deprecation": "已弃用 \"useWSL\" 并将停止对它的支持。请改用 \"Remote - WSL\" 扩展。",
			"node.launch.useWSL.description": "使用适用于 Linux 的 Windows 子系统。",
			"node.localRoot.description": "包含该程序的本地目录的路径。",
			"node.pauseForSourceMap.description": "是否等待每个传入脚本的源映射加载。 这会产生性能开销，只要没有禁用 rootPath，就可在磁盘空间不足时安全地禁用它。",
			"node.port.description": "调试要附加的端口。默认端口是 5858。",
			"node.processattach.config.name": "附加到进程",
			"node.profileStartup.description": "如果为 true，则将在进程启动后立即开始分析",
			"node.remoteRoot.description": "包含该程序的远程目录的绝对路径。",
			"node.resolveSourceMapLocations.description": "可用源映射来解析本地文件的位置(文件夹和 URL)的小型匹配模式列表。这可用于避免造成外部源映射代码中错误地出现中断。使用前缀为 \"!\" 的模式可将这些中断排除。也可将其设置为空数组或 null 以避免限制。",
			"node.showAsyncStacks.description": "显示导致当前调用堆栈的异步调用。",
			"node.snippet.attach.description": "附加到正在运行的 node 程序",
			"node.snippet.attach.label": "Node.js: 附加",
			"node.snippet.attachProcess.description": "打开进程选取器并选择附加到的 node 进程",
			"node.snippet.attachProcess.label": "Node.js: 附加到进程",
			"node.snippet.electron.description": "调试 Electron 主进程",
			"node.snippet.electron.label": "Node.js: Electron 主进程",
			"node.snippet.gulp.description": "调试 Gulp 任务(确保项目中已安装本地 Gulp)",
			"node.snippet.gulp.label": "Node.js: Gulp 任务",
			"node.snippet.launch.description": "在调试模式下启动节点计划",
			"node.snippet.launch.label": "Node.js: 启动程序",
			"node.snippet.mocha.description": "调试 mocha 测试",
			"node.snippet.mocha.label": "Node.js: Mocha 测试",
			"node.snippet.nodemon.description": "使用 nodemon 以在源更改时重新启动调试会话",
			"node.snippet.nodemon.label": "Node.js: Nodemon 安装程序",
			"node.snippet.npm.description": "通过 npm \"debug\" 脚本启动 node 程序",
			"node.snippet.npm.label": "Node.js: Launch via npm",
			"node.snippet.remoteattach.description": "附加到远程节点计划的调试端口",
			"node.snippet.remoteattach.label": "Node.js: 附加到远程程序",
			"node.snippet.yo.description": "调试 yeoman 生成器 (通过在项目文件夹中运行 \"npm link\" 进行安装)",
			"node.snippet.yo.label": "Node.js: Yeoman 生成器",
			"node.sourceMapPathOverrides.description": "一组重写源映射中源文件的位置为磁盘上所处位置的映射。",
			"node.sourceMaps.description": "使用 JavaScript 源映射(如存在)。",
			"node.stopOnEntry.description": "启动后自动停止程序。",
			"node.timeout.description": "重试此毫秒数以连接到 Node.js。默认值为 10000 毫秒。",
			"node.versionHint.description": "允许显式指定正在运行的节点版本，这可用于在自动版本检测不可用的情况下禁用或启用某些行为。",
			"node.websocket.address.description": "要附加到的确切 websocket 地址。如果未指定，将从地址和端口中发现它。",
			"outFiles.description": "如果启用了源映射，这些 glob 模式会指定生成的 JavaScript 文件。如果模式以 `!` 开头，则会排除这些文件。如果未指定，生成的代码应位于与其源相同的目录。",
			"pretty.print.script": "用于调试的美观格式打印",
			"profile.start": "获取性能配置文件",
			"profile.stop": "停止性能配置文件",
			"remove.browser.breakpoint": "删除浏览器断点",
			"remove.browser.breakpoint.all": "删除所有浏览器断点",
			"skipFiles.description": "调试时要跳过的文件的 glob 模式数组。模式 \"<node_internals>/**\" 与所有内部 Node.js 模块相匹配。",
			"smartStep.description": "通过单步执行自动生成的代码不能映射回原始源。",
			"start.with.stop.on.entry": "开始调试并在输入时停止",
			"timeouts.generalDescription": "多个调试程序操作的超时",
			"timeouts.generalDescription.markdown": "多个调试程序操作的超时",
			"timeouts.sourceMaps.description": "与源映射操作相关的超时",
			"timeouts.sourceMaps.sourceMapCumulativePause.description": "在最小时间(sourceMapMinPause)耗尽后，每个会话等待源映射被处理的额外时间(以毫秒为单位)",
			"timeouts.sourceMaps.sourceMapMinPause.description": "分析脚本时等待每个源映射被处理的最小时间(以毫秒为单位)",
			"toggle.skipping.this.file": "跳过此文件的开关",
			"trace.boolean.description": "跟踪可设置为 \"true\"，以将诊断日志写入磁盘。",
			"trace.console.description": "配置是否还将日志返回到调试控制台。",
			"trace.description": "配置生成哪些诊断输出。",
			"trace.level.description": "配置已记录的日志的级别。",
			"trace.logFile.description": "配置磁盘日志的写入位置。",
			"trace.stdio.description": "是否从启动的应用程序或浏览器返回跟踪数据。",
			"trace.tags.description": "配置记录的日志类型。"
		},
		"/src/binder": {
			"breakpoint.provisionalBreakpoint": "未绑定断点"
		},
		"/src/debugServer": {
			"breakpoint.provisionalBreakpoint": "未绑定断点"
		},
		"/src/vsDebugServer": {
			"session.rootSessionName": "JavaScript 调试适配器"
		},
		"/src/adapter/customBreakpoints": {
			"breakpoint.webglErrorNamed": "WebGL 错误“{0}”",
			"breakpoint.webglErrorNamedDetails": "因 WebGL 错误检测断点而暂停，错误为“{0}”",
			"breakpoint.cspViolationNamed": "CSP 违反“{0}”",
			"breakpoint.cspViolationNamedDetails": "因内容安全策略违规检测断点而暂停，指令“{0}”",
			"breakpoint.instrumentationNamed": "因检测断点“{0}”而暂停",
			"breakpoint.eventListenerNamed": "因事件侦听器断点“{0}”而暂停，于“{1}”触发",
			"breakpoint.requestAnimationFrame": "请求动画帧",
			"breakpoint.cancelAnimationFrame": "取消动画帧",
			"breakpoint.animationFrameFired": "已触发动画帧",
			"breakpoint.createCanvasContext": "创建画布上下文",
			"breakpoint.webglErrorFired": "已触发 WebGL 错误",
			"breakpoint.webglWarningFired": "已触发 WebGL 警告",
			"breakpoint.scriptFirstStatement": "编写第一条语句的脚本",
			"breakpoint.cspViolation": "脚本受到内容安全策略阻止",
			"breakpoint.setInnerHtml": "设置 innerHTML",
			"breakpoint.setTimeoutFired": "已触发 setTimeout",
			"breakpoint.setIntervalFired": "已触发 setInterval",
			"breakpoint.createAudioContext": "创建 AudioContext",
			"breakpoint.closeAudioContext": "关闭 AudioContext",
			"breakpoint.resumeAudioContext": "恢复 AudioContext",
			"breakpoint.suspendAudioContext": "暂停 AudioContext"
		},
		"/src/adapter/debugAdapter": {
			"breakpoint.caughtExceptions": "捕获的异常",
			"breakpoint.caughtExceptions.description": "Breaks on all throw errors, even if they're caught later.",
			"breakpoint.uncaughtExceptions": "未捕获的异常",
			"error.sourceNotFound": "未找到源",
			"error.sourceContentDidFail": "无法检索源内容",
			"error.variableNotFound": "找不到变量",
			"error.threadNotFound": "未找到线程",
			"error.cannotPrettyPrint": "无法优质打印"
		},
		"/src/adapter/sources": {
			"source.skipFiles": "已由 skipFiles 跳过"
		},
		"/src/adapter/stackTrace": {
			"scope.global": "全局",
			"scope.local": "本地",
			"scope.with": "With 块",
			"scope.closure": "闭包",
			"scope.catch": "Catch 块",
			"scope.block": "块",
			"scope.script": "脚本",
			"scope.eval": "Eval",
			"scope.module": "模块",
			"scope.closureNamed": "闭包({0})",
			"smartStepSkipLabel": "已由 smartStep 跳过",
			"scope.returnValue": "返回值"
		},
		"/src/adapter/threads": {
			"error.resumeDidFail": "无法恢复",
			"error.pauseDidFail": "无法暂停",
			"error.stepOverDidFail": "无法越过子函数",
			"error.stepInDidFail": "无法进入子函数",
			"error.stepOutDidFail": "无法跳出子函数",
			"error.stackFrameNotFound": "未找到堆栈帧",
			"error.evaluateOnAsyncStackFrame": "无法计算异步堆栈帧",
			"error.restartFrameAsync": "无法重启异步帧",
			"reason.description.restart": "暂停于框架条目",
			"error.threadNotPaused": "线程未暂停",
			"error.threadNotPausedOnException": "出现异常时线程未暂停",
			"error.evaluateDidFail": "无法计算",
			"pause.breakpoint": "因断点暂停",
			"pause.default": "已暂停",
			"pause.assert": "因断言暂停",
			"pause.debugCommand": "在 debug() 调用时暂停",
			"pause.DomBreakpoint": "因 DOM 断点暂停",
			"pause.exception": "因异常暂停",
			"pause.promiseRejection": "暂停于拒绝承诺",
			"pause.instrumentation": "因检测断点暂停",
			"pause.xhr": "在 XMLHttpRequest 或提取时暂停",
			"pause.oom": "在出现内存不足异常之前暂停",
			"pause.eventListener": "因事件侦听器暂停",
			"warnings.handleSourceMapPause.didNotWait": "警告: 处理 {0} 的源映射耗时超过 {1} 毫秒，因此我们继续执行，而不是等到脚本的所有断点都设置好。"
		},
		"/src/adapter/variables": {
			"error.variableNotFound": "找不到变量",
			"error.emptyExpression": "无法设置空值",
			"error.invalidExpression": "无效表达式",
			"error.setVariableDidFail": "无法设置变量值",
			"error.unknown": "未知错误",
			"error.failedToCustomizeObjectProperties": "属性自定义失败",
			"error.customValueDescriptionGeneratorFailed": "{0} (无法描述: {1})"
		},
		"/src/dap/errors": {
			"NVS_HOME.not.found.message": "属性 \"runtimeVersion\" 需要安装 Node.js 版本管理器 \"nvs\" 或 \"nvm\"。",
			"NVM_HOME.not.found.message": "属性 \"runtimeVersion\" 需要 Node.js 版本管理器 \"nvm-windows\" 或 \"nvs\"。",
			"runtime.version.not.found.message": "未使用版本管理器 {1} 安装 Node.js 版本“{0}”。",
			"VSND2011": "无法在终端启动调试目标({0})。",
			"VSND2029": "无法从文件加载环境变量({0})。",
			"runtime.node.notfound": "找不到 Node.js 二进制文件“{0}”: {1}。请确保 Node.js 已安装且位于你的路径中，或者在 launch.json 中设置 \"runtimeExecutable\"",
			"runtime.node.outdated": "“{0}”中的 Node 版本已过时(版本 {1})，我们至少需要 Node 8.x。",
			"invalidHitCondition": "命中条件“{0}”无效。应输入表达式，如 \"> 42\" 或 \"== 2\"。",
			"profile.error.generic": "从目标获取配置文件时出错。",
			"profile.error.concurrent": "请在启动新的配置文件之前停止正在运行的配置文件。",
			"noBrowserInstallFound": "在你的系统上找不到 {0} 安装项。请尝试安装它，或者在 launch.json 的 \"runtimeExecutable\" 中提供浏览器的绝对路径。",
			"browserVersionNotFound": "找不到 {0} 版本 {1}。可用的自动发现的版本包括: {2}。你可将 launch.json 中的 \"runtimeExecutable\" 设置为其中一个，或者提供浏览器可执行文件的绝对路径。",
			"error.browserLaunchError": "无法启动浏览器:“{0}”",
			"error.browserAttachError": "无法附加到浏览器",
			"error.threadNotFound": "找不到目标页。若要匹配想要调试的页面，可能需要更新 \"urlFilter\"。",
			"asyncScopesNotAvailable": "变量在异步堆栈中不可用",
			"breakpointSyntaxError": "在第 {1} 行上设置带条件 {0} 的断点时出现语法错误: {2}",
			"sourcemapParseError": "无法读取 {0} 的源映射: {1}"
		},
		"/src/ui/autoAttach": {
			"details": "详细信息"
		},
		"/src/ui/companionBrowserLaunch": {
			"cannotDebugInBrowser": "无法从此处启动调试模式下的浏览器。要启用调试，请在桌面上的 VS Code 中打开此工作区。"
		},
		"/src/ui/debugLinkUI": {
			"debugLink.invalidUrl": "提供的 URL 无效",
			"yes": "是",
			"never": "从不",
			"debugLink.savePrompt": "是否要将配置保存在 launch.json 中以便日后访问?",
			"no": "否"
		},
		"/src/ui/debugNpmScript": {
			"debug.npm.noWorkspaceFolder": "需要打开工作区文件夹来调试 npm 脚本。",
			"debug.npm.parseError": "无法读取 {0}: {1}",
			"debug.npm.noScripts": "在 package.json 中找不到 npm 脚本",
			"debug.npm.notFound.open": "编辑 package.json"
		},
		"/src/ui/debugTerminalUI": {
			"terminal.cwdpick": "选择当前工作目录新建终端"
		},
		"/src/ui/disableSourceMapUI": {
			"always": "始终",
			"yes": "是",
			"disableSourceMapUi.msg": "这是由源映射引用的缺失的文件路径。是否要改为调试编译版本?",
			"no": "否"
		},
		"/src/ui/experimentEnlist": {
			"experimentEnlist": "可使用 \"debug.javascript.usePreview\" 设置关闭新的调试器。请报告你遇到的所有问题，感谢你试用!"
		},
		"/src/ui/longPredictionUI": {
			"longPredictionWarning.message": "配置断点需要一段时间。你可通过更新 launch.json 中的 \"outFiles\" 来加快速度。",
			"longPredictionWarning.open": "打开 launch.json",
			"longPredictionWarning.disable": "不再显示",
			"longPredictionWarning.noFolder": "未打开工作区文件夹。"
		},
		"/src/ui/prettyPrint": {
			"yes": "是",
			"no": "否",
			"never": "从不"
		},
		"/src/ui/processPicker": {
			"process.id.error": "附加到进程:“{0}”不像是进程 ID。",
			"process.picker.error": "进程选取器失败 ({0})",
			"pickNodeProcess": "选择要附加到的 Node.js 进程",
			"process.id.port.signal": "进程 ID: {0}，调试端口: {1} ({2})",
			"process.id.signal": "进程 ID: {0} ({1})",
			"cannot.enable.debug.mode.error": "附加到进程: 无法对进程 \"{0}\" 启用调试模式 ({1})。"
		},
		"/src/ui/terminalLinkHandler": {
			"terminalLinkHover.debug": "调试 URL",
			"cantOpenChromeOnWeb": "无法从此处启动调试模式下的浏览器。若要调试此网页，请从桌面上的 VS Code 打开此工作区。"
		},
		"/src/adapter/breakpoints/userDefinedBreakpoint": {
			"breakpoint.provisionalBreakpoint": "未绑定断点"
		},
		"/src/adapter/console/queryObjectsMessage": {
			"queryObject.invalidObject": "只能查询对象",
			"queryObject.couldNotQuery": "无法查询提供的对象",
			"queryObject.errorPreview": "可以生成预览: {0}"
		},
		"/src/adapter/console/textualMessage": {
			"console.assert": "断言失败"
		},
		"/src/adapter/profiling/basicCpuProfiler": {
			"profile.cpu.label": "CPU 配置文件",
			"profile.cpu.description": "生成可在 Chrome 开发工具中打开的 .cpuprofile 文件"
		},
		"/src/targets/browser/browserAttacher": {
			"chrome.targets.placeholder": "选择一个选项卡",
			"attach.cannotConnect": "无法连接到 {0} 处的目标: {1}"
		},
		"/src/targets/node/nodeAttacher": {
			"node.attach.restart.message": "已断开与调试对象的连接，将在 {0} 毫秒后重新连接\r\n"
		},
		"/src/targets/node/nodeBinaryProvider": {
			"yes": "是",
			"outOfDate": "{0} 仍要尝试调试吗?",
			"runtime.node.notfound.enoent": "路径不存在",
			"runtime.node.notfound.spawnErr": "获取版本时出错: {0}"
		},
		"/src/targets/node/terminalProgramLauncher": {
			"node.console.title": "Node 调试控制台"
		},
		"/src/ui/configuration/chromiumDebugConfigurationProvider": {
			"existingBrowser.debugAnyway": "仍要调试",
			"existingBrowser.alert": "似乎已从 {0} 运行了浏览器。请在尝试调试前关闭它，否则 VS Code 可能无法连接它。",
			"existingBrowser.location.default": "旧调试会话",
			"existingBrowser.location.userDataDir": "已配置的 userDataDir",
			"cancel": "取消",
			"chrome.launch.name": "针对 localhost 启动 Chrome"
		},
		"/src/ui/configuration/nodeDebugConfigurationProvider": {
			"debug.terminal.label": "创建 JavaScript 调试终端",
			"node.launch.script": "运行脚本: {0}",
			"node.launch.currentFile": "运行当前文件"
		},
		"/src/ui/configuration/nodeDebugConfigurationResolver": {
			"program.not.found.message": "找不到要调试的程序",
			"node.launch.config.name": "启动程序",
			"mern.starter.explanation": "已创建“{0}”项目的启动配置。",
			"program.guessed.from.package.json.explanation": "已根据 \"package.json\" 生成启动配置。",
			"outFiles.explanation": "在“outFiles”属性中调整glob模式，以包含生成的JavaScript。"
		},
		"/src/ui/profiling/breakpointTerminationCondition": {
			"profile.termination.breakpoint.label": "选取断点",
			"profile.termination.breakpoint.description": "运行直到命中特定断点为止",
			"breakpointTerminationWarnSlow": "在启用断点的情况下分析可能会更改代码的性能。使用“持续时间”或“手动”终止条件验证发现的结果可能很有用。",
			"breakpointTerminationWarnConfirm": "知道了!"
		},
		"/src/ui/profiling/durationTerminationCondition": {
			"profile.termination.duration.label": "持续时间",
			"profile.termination.duration.description": "运行特定时间",
			"profile.termination.duration.inputTitle": "配置文件的持续时间",
			"profile.termination.duration.placeholder": "配置文件持续时间(以秒为单位)，例如 \"5\"",
			"profile.termination.duration.invalidFormat": "请输入数字",
			"profile.termination.duration.invalidLength": "请输入一个大于 1 的数字"
		},
		"/src/ui/profiling/manualTerminationCondition": {
			"profile.termination.duration.label": "手动",
			"profile.termination.duration.description": "运行直到手动停止为止"
		},
		"/src/ui/profiling/uiProfileManager": {
			"profile.sessionState": "分析",
			"profile.status.single": "$(loading) 单击以停止分析({0})",
			"profile.status.default": "$(loading) 单击以停止分析",
			"profile.status.multiSession": "$(loading) 单击以停止分析({0} 个会话)",
			"yes": "是",
			"no": "否",
			"profile.alreadyRunning": "分析会话已在运行，是否要停止它并开始新会话?",
			"profile.type.title": "配置文件的类型:",
			"profile.termination.title": "配置文件的运行时长:"
		},
		"/src/ui/profiling/uiProfileSession": {
			"profile.saving": "正在保存"
		}
	}
}