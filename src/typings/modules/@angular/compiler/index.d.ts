// Generated by typings
// Source: node_modules/@angular/compiler/src/version.d.ts
declare module '~@angular/compiler/src/version' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the common package.
 */
import { Version } from '@angular/core';
/**
 * @stable
 */
export const VERSION: Version;
}
declare module '@angular/compiler/src/version' {
export * from '~@angular/compiler/src/version';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/template_parser/template_ast.d.ts
declare module '~@angular/compiler/src/template_parser/template_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SecurityContext, ɵLifecycleHooks as LifecycleHooks } from '@angular/core';
import { CompileDirectiveSummary, CompileProviderMetadata, CompileTokenMetadata } from '~@angular/compiler/src/compile_metadata';
import { AST } from '~@angular/compiler/src/expression_parser/ast';
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
/**
 * An Abstract Syntax Tree node representing part of a parsed Angular template.
 */
export interface TemplateAst {
    /**
     * The source span from which this node was parsed.
     */
    sourceSpan: ParseSourceSpan;
    /**
     * Visit this node and possibly transform it.
     */
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A segment of text within the template.
 */
export class TextAst implements TemplateAst {
    value: string;
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A bound expression within the text of a template.
 */
export class BoundTextAst implements TemplateAst {
    value: AST;
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(value: AST, ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A plain attribute on an element.
 */
export class AttrAst implements TemplateAst {
    name: string;
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A binding for an element property (e.g. `[property]="expression"`) or an animation trigger (e.g.
 * `[@trigger]="stateExp"`)
 */
export class BoundElementPropertyAst implements TemplateAst {
    name: string;
    type: PropertyBindingType;
    securityContext: SecurityContext;
    value: AST;
    unit: string | null;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, type: PropertyBindingType, securityContext: SecurityContext, value: AST, unit: string | null, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
    readonly isAnimation: boolean;
}
/**
 * A binding for an element event (e.g. `(event)="handler()"`) or an animation trigger event (e.g.
 * `(@trigger.phase)="callback($event)"`).
 */
export class BoundEventAst implements TemplateAst {
    name: string;
    target: string | null;
    phase: string | null;
    handler: AST;
    sourceSpan: ParseSourceSpan;
    static calcFullName(name: string, target: string | null, phase: string | null): string;
    constructor(name: string, target: string | null, phase: string | null, handler: AST, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
    readonly fullName: string;
    readonly isAnimation: boolean;
}
/**
 * A reference declaration on an element (e.g. `let someName="expression"`).
 */
export class ReferenceAst implements TemplateAst {
    name: string;
    value: CompileTokenMetadata;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, value: CompileTokenMetadata, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A variable declaration on a <ng-template> (e.g. `var-someName="someLocalName"`).
 */
export class VariableAst implements TemplateAst {
    name: string;
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * An element declaration in a template.
 */
export class ElementAst implements TemplateAst {
    name: string;
    attrs: AttrAst[];
    inputs: BoundElementPropertyAst[];
    outputs: BoundEventAst[];
    references: ReferenceAst[];
    directives: DirectiveAst[];
    providers: ProviderAst[];
    hasViewContainer: boolean;
    queryMatches: QueryMatch[];
    children: TemplateAst[];
    ngContentIndex: number | null;
    sourceSpan: ParseSourceSpan;
    endSourceSpan: ParseSourceSpan | null;
    constructor(name: string, attrs: AttrAst[], inputs: BoundElementPropertyAst[], outputs: BoundEventAst[], references: ReferenceAst[], directives: DirectiveAst[], providers: ProviderAst[], hasViewContainer: boolean, queryMatches: QueryMatch[], children: TemplateAst[], ngContentIndex: number | null, sourceSpan: ParseSourceSpan, endSourceSpan: ParseSourceSpan | null);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A `<ng-template>` element included in an Angular template.
 */
export class EmbeddedTemplateAst implements TemplateAst {
    attrs: AttrAst[];
    outputs: BoundEventAst[];
    references: ReferenceAst[];
    variables: VariableAst[];
    directives: DirectiveAst[];
    providers: ProviderAst[];
    hasViewContainer: boolean;
    queryMatches: QueryMatch[];
    children: TemplateAst[];
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(attrs: AttrAst[], outputs: BoundEventAst[], references: ReferenceAst[], variables: VariableAst[], directives: DirectiveAst[], providers: ProviderAst[], hasViewContainer: boolean, queryMatches: QueryMatch[], children: TemplateAst[], ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A directive property with a bound value (e.g. `*ngIf="condition").
 */
export class BoundDirectivePropertyAst implements TemplateAst {
    directiveName: string;
    templateName: string;
    value: AST;
    sourceSpan: ParseSourceSpan;
    constructor(directiveName: string, templateName: string, value: AST, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A directive declared on an element.
 */
export class DirectiveAst implements TemplateAst {
    directive: CompileDirectiveSummary;
    inputs: BoundDirectivePropertyAst[];
    hostProperties: BoundElementPropertyAst[];
    hostEvents: BoundEventAst[];
    contentQueryStartId: number;
    sourceSpan: ParseSourceSpan;
    constructor(directive: CompileDirectiveSummary, inputs: BoundDirectivePropertyAst[], hostProperties: BoundElementPropertyAst[], hostEvents: BoundEventAst[], contentQueryStartId: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A provider declared on an element
 */
export class ProviderAst implements TemplateAst {
    token: CompileTokenMetadata;
    multiProvider: boolean;
    eager: boolean;
    providers: CompileProviderMetadata[];
    providerType: ProviderAstType;
    lifecycleHooks: LifecycleHooks[];
    sourceSpan: ParseSourceSpan;
    constructor(token: CompileTokenMetadata, multiProvider: boolean, eager: boolean, providers: CompileProviderMetadata[], providerType: ProviderAstType, lifecycleHooks: LifecycleHooks[], sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
export enum ProviderAstType {
    PublicService = 0,
    PrivateService = 1,
    Component = 2,
    Directive = 3,
    Builtin = 4,
}
/**
 * Position where content is to be projected (instance of `<ng-content>` in a template).
 */
export class NgContentAst implements TemplateAst {
    index: number;
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(index: number, ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * Enumeration of types of property bindings.
 */
export enum PropertyBindingType {
    /**
     * A normal binding to a property (e.g. `[property]="expression"`).
     */
    Property = 0,
    /**
     * A binding to an element attribute (e.g. `[attr.name]="expression"`).
     */
    Attribute = 1,
    /**
     * A binding to a CSS class (e.g. `[class.name]="condition"`).
     */
    Class = 2,
    /**
     * A binding to a style rule (e.g. `[style.rule]="expression"`).
     */
    Style = 3,
    /**
     * A binding to an animation reference (e.g. `[animate.key]="expression"`).
     */
    Animation = 4,
}
export interface QueryMatch {
    queryId: number;
    value: CompileTokenMetadata;
}
/**
 * A visitor for {@link TemplateAst} trees that will process each node.
 */
export interface TemplateAstVisitor {
    visit?(ast: TemplateAst, context: any): any;
    visitNgContent(ast: NgContentAst, context: any): any;
    visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any;
    visitElement(ast: ElementAst, context: any): any;
    visitReference(ast: ReferenceAst, context: any): any;
    visitVariable(ast: VariableAst, context: any): any;
    visitEvent(ast: BoundEventAst, context: any): any;
    visitElementProperty(ast: BoundElementPropertyAst, context: any): any;
    visitAttr(ast: AttrAst, context: any): any;
    visitBoundText(ast: BoundTextAst, context: any): any;
    visitText(ast: TextAst, context: any): any;
    visitDirective(ast: DirectiveAst, context: any): any;
    visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any;
}
/**
 * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
 */
export function templateVisitAll(visitor: TemplateAstVisitor, asts: TemplateAst[], context?: any): any[];
}
declare module '@angular/compiler/src/template_parser/template_ast' {
export * from '~@angular/compiler/src/template_parser/template_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/i18n_html_parser.d.ts
declare module '~@angular/compiler/src/i18n/i18n_html_parser' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { MissingTranslationStrategy, ɵConsole as Console } from '@angular/core';
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseTreeResult } from '~@angular/compiler/src/ml_parser/parser';
export class I18NHtmlParser implements HtmlParser {
    private _htmlParser;
    getTagDefinition: any;
    private _translationBundle;
    constructor(_htmlParser: HtmlParser, translations?: string, translationsFormat?: string, missingTranslation?: MissingTranslationStrategy, console?: Console);
    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;
}
}
declare module '@angular/compiler/src/i18n/i18n_html_parser' {
export * from '~@angular/compiler/src/i18n/i18n_html_parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/template_parser/template_parser.d.ts
declare module '~@angular/compiler/src/template_parser/template_parser' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { InjectionToken, SchemaMetadata, ɵConsole as Console } from '@angular/core';
import { CompileDirectiveMetadata, CompileDirectiveSummary, CompilePipeSummary, CompileTypeMetadata } from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { Parser } from '~@angular/compiler/src/expression_parser/parser';
import { I18NHtmlParser } from '~@angular/compiler/src/i18n/i18n_html_parser';
import { ParseTreeResult } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseError, ParseErrorLevel, ParseSourceSpan } from '~@angular/compiler/src/parse_util';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
import { CssSelector } from '~@angular/compiler/src/selector';
import { TemplateAst, TemplateAstVisitor } from '~@angular/compiler/src/template_parser/template_ast';
/**
 * Provides an array of {@link TemplateAstVisitor}s which will be used to transform
 * parsed templates before compilation is invoked, allowing custom expression syntax
 * and other advanced transformations.
 *
 * This is currently an internal-only feature and not meant for general use.
 */
export const TEMPLATE_TRANSFORMS: InjectionToken<{}>;
export class TemplateParseError extends ParseError {
    constructor(message: string, span: ParseSourceSpan, level: ParseErrorLevel);
}
export class TemplateParseResult {
    templateAst: TemplateAst[];
    usedPipes: CompilePipeSummary[];
    errors: ParseError[];
    constructor(templateAst?: TemplateAst[], usedPipes?: CompilePipeSummary[], errors?: ParseError[]);
}
export class TemplateParser {
    private _config;
    private _exprParser;
    private _schemaRegistry;
    private _htmlParser;
    private _console;
    transforms: TemplateAstVisitor[];
    constructor(_config: CompilerConfig, _exprParser: Parser, _schemaRegistry: ElementSchemaRegistry, _htmlParser: I18NHtmlParser, _console: Console, transforms: TemplateAstVisitor[]);
    parse(component: CompileDirectiveMetadata, template: string, directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[], templateUrl: string): {
        template: TemplateAst[];
        pipes: CompilePipeSummary[];
    };
    tryParse(component: CompileDirectiveMetadata, template: string, directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[], templateUrl: string): TemplateParseResult;
    tryParseHtml(htmlAstWithErrors: ParseTreeResult, component: CompileDirectiveMetadata, directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[]): TemplateParseResult;
    expandHtml(htmlAstWithErrors: ParseTreeResult, forced?: boolean): ParseTreeResult;
    getInterpolationConfig(component: CompileDirectiveMetadata): InterpolationConfig | undefined;
}
export function splitClasses(classAttrValue: string): string[];
export function createElementCssSelector(elementName: string, attributes: [string, string][]): CssSelector;
export function removeSummaryDuplicates<T extends {
    type: CompileTypeMetadata;
}>(items: T[]): T[];
}
declare module '@angular/compiler/src/template_parser/template_parser' {
export * from '~@angular/compiler/src/template_parser/template_parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/config.d.ts
declare module '~@angular/compiler/src/config' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { MissingTranslationStrategy, ViewEncapsulation } from '@angular/core';
export class CompilerConfig {
    defaultEncapsulation: ViewEncapsulation | null;
    enableLegacyTemplate: boolean;
    useJit: boolean;
    missingTranslation: MissingTranslationStrategy | null;
    constructor({defaultEncapsulation, useJit, missingTranslation, enableLegacyTemplate}?: {
        defaultEncapsulation?: ViewEncapsulation;
        useJit?: boolean;
        missingTranslation?: MissingTranslationStrategy;
        enableLegacyTemplate?: boolean;
    });
}
}
declare module '@angular/compiler/src/config' {
export * from '~@angular/compiler/src/config';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/compile_metadata.d.ts
declare module '~@angular/compiler/src/compile_metadata' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, ComponentFactory, RendererType2, SchemaMetadata, Type, ViewEncapsulation, ɵLifecycleHooks } from '@angular/core';
import { StaticSymbol } from '~@angular/compiler/src/aot/static_symbol';
export class CompileAnimationEntryMetadata {
    name: string | null;
    definitions: CompileAnimationStateMetadata[] | null;
    constructor(name?: string | null, definitions?: CompileAnimationStateMetadata[] | null);
}
export abstract class CompileAnimationStateMetadata {
}
export class CompileAnimationStateDeclarationMetadata extends CompileAnimationStateMetadata {
    stateNameExpr: string;
    styles: CompileAnimationStyleMetadata;
    constructor(stateNameExpr: string, styles: CompileAnimationStyleMetadata);
}
export class CompileAnimationStateTransitionMetadata extends CompileAnimationStateMetadata {
    stateChangeExpr: string | StaticSymbol | ((stateA: string, stateB: string) => boolean);
    steps: CompileAnimationMetadata;
    constructor(stateChangeExpr: string | StaticSymbol | ((stateA: string, stateB: string) => boolean), steps: CompileAnimationMetadata);
}
export abstract class CompileAnimationMetadata {
}
export class CompileAnimationKeyframesSequenceMetadata extends CompileAnimationMetadata {
    steps: CompileAnimationStyleMetadata[];
    constructor(steps?: CompileAnimationStyleMetadata[]);
}
export class CompileAnimationStyleMetadata extends CompileAnimationMetadata {
    offset: number;
    styles: Array<string | {
        [key: string]: string | number;
    }> | null;
    constructor(offset: number, styles?: Array<string | {
        [key: string]: string | number;
    }> | null);
}
export class CompileAnimationAnimateMetadata extends CompileAnimationMetadata {
    timings: string | number;
    styles: CompileAnimationStyleMetadata | CompileAnimationKeyframesSequenceMetadata | null;
    constructor(timings?: string | number, styles?: CompileAnimationStyleMetadata | CompileAnimationKeyframesSequenceMetadata | null);
}
export abstract class CompileAnimationWithStepsMetadata extends CompileAnimationMetadata {
    steps: CompileAnimationMetadata[] | null;
    constructor(steps?: CompileAnimationMetadata[] | null);
}
export class CompileAnimationSequenceMetadata extends CompileAnimationWithStepsMetadata {
    constructor(steps?: CompileAnimationMetadata[] | null);
}
export class CompileAnimationGroupMetadata extends CompileAnimationWithStepsMetadata {
    constructor(steps?: CompileAnimationMetadata[] | null);
}
export function identifierName(compileIdentifier: CompileIdentifierMetadata | null | undefined): string | null;
export function identifierModuleUrl(compileIdentifier: CompileIdentifierMetadata): string;
export function viewClassName(compType: any, embeddedTemplateIndex: number): string;
export function rendererTypeName(compType: any): string;
export function hostViewClassName(compType: any): string;
export function dirWrapperClassName(dirType: any): string;
export function componentFactoryName(compType: any): string;
export interface ProxyClass {
    setDelegate(delegate: any): void;
}
export interface CompileIdentifierMetadata {
    reference: any;
}
export enum CompileSummaryKind {
    Pipe = 0,
    Directive = 1,
    NgModule = 2,
    Injectable = 3,
}
/**
 * A CompileSummary is the data needed to use a directive / pipe / module
 * in other modules / components. However, this data is not enough to compile
 * the directive / module itself.
 */
export interface CompileTypeSummary {
    summaryKind: CompileSummaryKind | null;
    type: CompileTypeMetadata;
}
export interface CompileDiDependencyMetadata {
    isAttribute?: boolean;
    isSelf?: boolean;
    isHost?: boolean;
    isSkipSelf?: boolean;
    isOptional?: boolean;
    isValue?: boolean;
    token?: CompileTokenMetadata;
    value?: any;
}
export interface CompileProviderMetadata {
    token: CompileTokenMetadata;
    useClass?: CompileTypeMetadata;
    useValue?: any;
    useExisting?: CompileTokenMetadata;
    useFactory?: CompileFactoryMetadata;
    deps?: CompileDiDependencyMetadata[];
    multi?: boolean;
}
export interface CompileFactoryMetadata extends CompileIdentifierMetadata {
    diDeps: CompileDiDependencyMetadata[];
    reference: any;
}
export function tokenName(token: CompileTokenMetadata): string | null;
export function tokenReference(token: CompileTokenMetadata): any;
export interface CompileTokenMetadata {
    value?: any;
    identifier?: CompileIdentifierMetadata | CompileTypeMetadata;
}
/**
 * Metadata regarding compilation of a type.
 */
export interface CompileTypeMetadata extends CompileIdentifierMetadata {
    diDeps: CompileDiDependencyMetadata[];
    lifecycleHooks: ɵLifecycleHooks[];
    reference: any;
}
export interface CompileQueryMetadata {
    selectors: Array<CompileTokenMetadata>;
    descendants: boolean;
    first: boolean;
    propertyName: string;
    read: CompileTokenMetadata;
}
/**
 * Metadata about a stylesheet
 */
export class CompileStylesheetMetadata {
    moduleUrl: string | null;
    styles: string[];
    styleUrls: string[];
    constructor({moduleUrl, styles, styleUrls}?: {
        moduleUrl?: string;
        styles?: string[];
        styleUrls?: string[];
    });
}
/**
 * Summary Metadata regarding compilation of a template.
 */
export interface CompileTemplateSummary {
    animations: string[] | null;
    ngContentSelectors: string[];
    encapsulation: ViewEncapsulation | null;
}
/**
 * Metadata regarding compilation of a template.
 */
export class CompileTemplateMetadata {
    encapsulation: ViewEncapsulation | null;
    template: string | null;
    templateUrl: string | null;
    isInline: boolean;
    styles: string[];
    styleUrls: string[];
    externalStylesheets: CompileStylesheetMetadata[];
    animations: any[];
    ngContentSelectors: string[];
    interpolation: [string, string] | null;
    constructor({encapsulation, template, templateUrl, styles, styleUrls, externalStylesheets, animations, ngContentSelectors, interpolation, isInline}: {
        encapsulation: ViewEncapsulation | null;
        template: string | null;
        templateUrl: string | null;
        styles: string[];
        styleUrls: string[];
        externalStylesheets: CompileStylesheetMetadata[];
        ngContentSelectors: string[];
        animations: any[];
        interpolation: [string, string] | null;
        isInline: boolean;
    });
    toSummary(): CompileTemplateSummary;
}
export interface CompileEntryComponentMetadata {
    componentType: any;
    componentFactory: StaticSymbol | ComponentFactory<any>;
}
export interface CompileDirectiveSummary extends CompileTypeSummary {
    type: CompileTypeMetadata;
    isComponent: boolean;
    selector: string | null;
    exportAs: string | null;
    inputs: {
        [key: string]: string;
    };
    outputs: {
        [key: string]: string;
    };
    hostListeners: {
        [key: string]: string;
    };
    hostProperties: {
        [key: string]: string;
    };
    hostAttributes: {
        [key: string]: string;
    };
    providers: CompileProviderMetadata[];
    viewProviders: CompileProviderMetadata[];
    queries: CompileQueryMetadata[];
    viewQueries: CompileQueryMetadata[];
    entryComponents: CompileEntryComponentMetadata[];
    changeDetection: ChangeDetectionStrategy | null;
    template: CompileTemplateSummary | null;
    componentViewType: StaticSymbol | ProxyClass | null;
    rendererType: StaticSymbol | RendererType2 | null;
    componentFactory: StaticSymbol | ComponentFactory<any> | null;
}
/**
 * Metadata regarding compilation of a directive.
 */
export class CompileDirectiveMetadata {
    static create({isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, host, providers, viewProviders, queries, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory}: {
        isHost: boolean;
        type: CompileTypeMetadata;
        isComponent: boolean;
        selector: string | null;
        exportAs: string | null;
        changeDetection: ChangeDetectionStrategy | null;
        inputs: string[];
        outputs: string[];
        host: {
            [key: string]: string;
        };
        providers: CompileProviderMetadata[];
        viewProviders: CompileProviderMetadata[];
        queries: CompileQueryMetadata[];
        viewQueries: CompileQueryMetadata[];
        entryComponents: CompileEntryComponentMetadata[];
        template: CompileTemplateMetadata;
        componentViewType: StaticSymbol | ProxyClass | null;
        rendererType: StaticSymbol | RendererType2 | null;
        componentFactory: StaticSymbol | ComponentFactory<any> | null;
    }): CompileDirectiveMetadata;
    isHost: boolean;
    type: CompileTypeMetadata;
    isComponent: boolean;
    selector: string | null;
    exportAs: string | null;
    changeDetection: ChangeDetectionStrategy | null;
    inputs: {
        [key: string]: string;
    };
    outputs: {
        [key: string]: string;
    };
    hostListeners: {
        [key: string]: string;
    };
    hostProperties: {
        [key: string]: string;
    };
    hostAttributes: {
        [key: string]: string;
    };
    providers: CompileProviderMetadata[];
    viewProviders: CompileProviderMetadata[];
    queries: CompileQueryMetadata[];
    viewQueries: CompileQueryMetadata[];
    entryComponents: CompileEntryComponentMetadata[];
    template: CompileTemplateMetadata | null;
    componentViewType: StaticSymbol | ProxyClass | null;
    rendererType: StaticSymbol | RendererType2 | null;
    componentFactory: StaticSymbol | ComponentFactory<any> | null;
    constructor({isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, hostListeners, hostProperties, hostAttributes, providers, viewProviders, queries, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory}: {
        isHost: boolean;
        type: CompileTypeMetadata;
        isComponent: boolean;
        selector: string | null;
        exportAs: string | null;
        changeDetection: ChangeDetectionStrategy | null;
        inputs: {
            [key: string]: string;
        };
        outputs: {
            [key: string]: string;
        };
        hostListeners: {
            [key: string]: string;
        };
        hostProperties: {
            [key: string]: string;
        };
        hostAttributes: {
            [key: string]: string;
        };
        providers: CompileProviderMetadata[];
        viewProviders: CompileProviderMetadata[];
        queries: CompileQueryMetadata[];
        viewQueries: CompileQueryMetadata[];
        entryComponents: CompileEntryComponentMetadata[];
        template: CompileTemplateMetadata | null;
        componentViewType: StaticSymbol | ProxyClass | null;
        rendererType: StaticSymbol | RendererType2 | null;
        componentFactory: StaticSymbol | ComponentFactory<any> | null;
    });
    toSummary(): CompileDirectiveSummary;
}
/**
 * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.
 */
export function createHostComponentMeta(hostTypeReference: any, compMeta: CompileDirectiveMetadata, hostViewType: StaticSymbol | ProxyClass): CompileDirectiveMetadata;
export interface CompilePipeSummary extends CompileTypeSummary {
    type: CompileTypeMetadata;
    name: string;
    pure: boolean;
}
export class CompilePipeMetadata {
    type: CompileTypeMetadata;
    name: string;
    pure: boolean;
    constructor({type, name, pure}: {
        type: CompileTypeMetadata;
        name: string;
        pure: boolean;
    });
    toSummary(): CompilePipeSummary;
}
export interface CompileNgModuleSummary extends CompileTypeSummary {
    type: CompileTypeMetadata;
    exportedDirectives: CompileIdentifierMetadata[];
    exportedPipes: CompileIdentifierMetadata[];
    entryComponents: CompileEntryComponentMetadata[];
    providers: {
        provider: CompileProviderMetadata;
        module: CompileIdentifierMetadata;
    }[];
    modules: CompileTypeMetadata[];
}
/**
 * Metadata regarding compilation of a module.
 */
export class CompileNgModuleMetadata {
    type: CompileTypeMetadata;
    declaredDirectives: CompileIdentifierMetadata[];
    exportedDirectives: CompileIdentifierMetadata[];
    declaredPipes: CompileIdentifierMetadata[];
    exportedPipes: CompileIdentifierMetadata[];
    entryComponents: CompileEntryComponentMetadata[];
    bootstrapComponents: CompileIdentifierMetadata[];
    providers: CompileProviderMetadata[];
    importedModules: CompileNgModuleSummary[];
    exportedModules: CompileNgModuleSummary[];
    schemas: SchemaMetadata[];
    id: string | null;
    transitiveModule: TransitiveCompileNgModuleMetadata;
    constructor({type, providers, declaredDirectives, exportedDirectives, declaredPipes, exportedPipes, entryComponents, bootstrapComponents, importedModules, exportedModules, schemas, transitiveModule, id}: {
        type: CompileTypeMetadata;
        providers: CompileProviderMetadata[];
        declaredDirectives: CompileIdentifierMetadata[];
        exportedDirectives: CompileIdentifierMetadata[];
        declaredPipes: CompileIdentifierMetadata[];
        exportedPipes: CompileIdentifierMetadata[];
        entryComponents: CompileEntryComponentMetadata[];
        bootstrapComponents: CompileIdentifierMetadata[];
        importedModules: CompileNgModuleSummary[];
        exportedModules: CompileNgModuleSummary[];
        transitiveModule: TransitiveCompileNgModuleMetadata;
        schemas: SchemaMetadata[];
        id: string | null;
    });
    toSummary(): CompileNgModuleSummary;
}
export class TransitiveCompileNgModuleMetadata {
    directivesSet: Set<any>;
    directives: CompileIdentifierMetadata[];
    exportedDirectivesSet: Set<any>;
    exportedDirectives: CompileIdentifierMetadata[];
    pipesSet: Set<any>;
    pipes: CompileIdentifierMetadata[];
    exportedPipesSet: Set<any>;
    exportedPipes: CompileIdentifierMetadata[];
    modulesSet: Set<any>;
    modules: CompileTypeMetadata[];
    entryComponentsSet: Set<any>;
    entryComponents: CompileEntryComponentMetadata[];
    providers: {
        provider: CompileProviderMetadata;
        module: CompileIdentifierMetadata;
    }[];
    addProvider(provider: CompileProviderMetadata, module: CompileIdentifierMetadata): void;
    addDirective(id: CompileIdentifierMetadata): void;
    addExportedDirective(id: CompileIdentifierMetadata): void;
    addPipe(id: CompileIdentifierMetadata): void;
    addExportedPipe(id: CompileIdentifierMetadata): void;
    addModule(id: CompileTypeMetadata): void;
    addEntryComponent(ec: CompileEntryComponentMetadata): void;
}
export class ProviderMeta {
    token: any;
    useClass: Type<any> | null;
    useValue: any;
    useExisting: any;
    useFactory: Function | null;
    dependencies: Object[] | null;
    multi: boolean;
    constructor(token: any, {useClass, useValue, useExisting, useFactory, deps, multi}: {
        useClass?: Type<any>;
        useValue?: any;
        useExisting?: any;
        useFactory?: Function | null;
        deps?: Object[] | null;
        multi?: boolean;
    });
}
export function flatten<T>(list: Array<T | T[]>): T[];
export function sourceUrl(url: string): string;
export function templateSourceUrl(ngModuleType: CompileIdentifierMetadata, compMeta: {
    type: CompileIdentifierMetadata;
}, templateMeta: {
    isInline: boolean;
    templateUrl: string | null;
}): string;
export function sharedStylesheetJitUrl(meta: CompileStylesheetMetadata, id: number): string;
export function ngModuleJitUrl(moduleMeta: CompileNgModuleMetadata): string;
export function templateJitUrl(ngModuleType: CompileIdentifierMetadata, compMeta: CompileDirectiveMetadata): string;
}
declare module '@angular/compiler/src/compile_metadata' {
export * from '~@angular/compiler/src/compile_metadata';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/compiler_factory.d.ts
declare module '~@angular/compiler/src/aot/compiler_factory' {
import { AotCompiler } from '~@angular/compiler/src/aot/compiler';
import { AotCompilerHost } from '~@angular/compiler/src/aot/compiler_host';
import { AotCompilerOptions } from '~@angular/compiler/src/aot/compiler_options';
import { StaticReflector } from '~@angular/compiler/src/aot/static_reflector';
/**
 * Creates a new AotCompiler based on options and a host.
 */
export function createAotCompiler(compilerHost: AotCompilerHost, options: AotCompilerOptions): {
    compiler: AotCompiler;
    reflector: StaticReflector;
};
}
declare module '@angular/compiler/src/aot/compiler_factory' {
export * from '~@angular/compiler/src/aot/compiler_factory';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/source_map.d.ts
declare module '~@angular/compiler/src/output/source_map' {
export type SourceMap = {
    version: number;
    file?: string;
    sourceRoot: string;
    sources: string[];
    sourcesContent: (string | null)[];
    mappings: string;
};
export class SourceMapGenerator {
    private file;
    private sourcesContent;
    private lines;
    private lastCol0;
    private hasMappings;
    constructor(file?: string | null);
    addSource(url: string, content?: string | null): this;
    addLine(): this;
    addMapping(col0: number, sourceUrl?: string, sourceLine0?: number, sourceCol0?: number): this;
    private readonly currentLine;
    toJSON(): SourceMap | null;
    toJsComment(): string;
}
export function toBase64String(value: string): string;
}
declare module '@angular/compiler/src/output/source_map' {
export * from '~@angular/compiler/src/output/source_map';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/abstract_emitter.d.ts
declare module '~@angular/compiler/src/output/abstract_emitter' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
import * as o from '~@angular/compiler/src/output/output_ast';
import { SourceMapGenerator } from '~@angular/compiler/src/output/source_map';
export const CATCH_ERROR_VAR: o.ReadVarExpr;
export const CATCH_STACK_VAR: o.ReadVarExpr;
export abstract class OutputEmitter {
    abstract emitStatements(srcFilePath: string, genFilePath: string, stmts: o.Statement[], exportedVars: string[], preamble?: string | null): string;
}
export class EmitterVisitorContext {
    private _exportedVars;
    private _indent;
    static createRoot(exportedVars: string[]): EmitterVisitorContext;
    private _lines;
    private _classes;
    constructor(_exportedVars: string[], _indent: number);
    private readonly _currentLine;
    isExportedVar(varName: string): boolean;
    println(from?: {
        sourceSpan: ParseSourceSpan | null;
    } | null, lastPart?: string): void;
    lineIsEmpty(): boolean;
    print(from: {
        sourceSpan: ParseSourceSpan | null;
    } | null, part: string, newLine?: boolean): void;
    removeEmptyLastLine(): void;
    incIndent(): void;
    decIndent(): void;
    pushClass(clazz: o.ClassStmt): void;
    popClass(): o.ClassStmt;
    readonly currentClass: o.ClassStmt | null;
    toSource(): string;
    toSourceMapGenerator(sourceFilePath: string, genFilePath: string, startsAtLine?: number): SourceMapGenerator;
    private readonly sourceLines;
}
export abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {
    private _escapeDollarInStrings;
    constructor(_escapeDollarInStrings: boolean);
    visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any;
    visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any;
    abstract visitCastExpr(ast: o.CastExpr, context: any): any;
    abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;
    visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any;
    abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;
    visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any;
    visitCommentStmt(stmt: o.CommentStmt, ctx: EmitterVisitorContext): any;
    abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;
    visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any;
    visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any;
    visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any;
    visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any;
    abstract getBuiltinMethodName(method: o.BuiltinMethod): string;
    visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any;
    visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any;
    visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any;
    visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any;
    abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;
    visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any;
    visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any;
    abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;
    abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;
    visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any;
    visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any;
    visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any;
    visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any;
    visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any;
    visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any;
    visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string, newLine?: boolean): void;
    visitAllObjects<T>(handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext, separator: string, newLine?: boolean): void;
    visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void;
}
export function escapeIdentifier(input: string, escapeDollar: boolean, alwaysQuote?: boolean): any;
}
declare module '@angular/compiler/src/output/abstract_emitter' {
export * from '~@angular/compiler/src/output/abstract_emitter';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/compiler.d.ts
declare module '~@angular/compiler/src/aot/compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileNgModuleMetadata } from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { CompileMetadataResolver } from '~@angular/compiler/src/metadata_resolver';
import { NgModuleCompiler } from '~@angular/compiler/src/ng_module_compiler';
import { OutputEmitter } from '~@angular/compiler/src/output/abstract_emitter';
import { StyleCompiler } from '~@angular/compiler/src/style_compiler';
import { SummaryResolver } from '~@angular/compiler/src/summary_resolver';
import { TemplateParser } from '~@angular/compiler/src/template_parser/template_parser';
import { ViewCompiler } from '~@angular/compiler/src/view_compiler/view_compiler';
import { AotCompilerHost } from '~@angular/compiler/src/aot/compiler_host';
import { GeneratedFile } from '~@angular/compiler/src/aot/generated_file';
import { StaticSymbol } from '~@angular/compiler/src/aot/static_symbol';
import { StaticSymbolResolver } from '~@angular/compiler/src/aot/static_symbol_resolver';
export class AotCompiler {
    private _config;
    private _host;
    private _metadataResolver;
    private _templateParser;
    private _styleCompiler;
    private _viewCompiler;
    private _ngModuleCompiler;
    private _outputEmitter;
    private _summaryResolver;
    private _localeId;
    private _translationFormat;
    private _genFilePreamble;
    private _symbolResolver;
    constructor(_config: CompilerConfig, _host: AotCompilerHost, _metadataResolver: CompileMetadataResolver, _templateParser: TemplateParser, _styleCompiler: StyleCompiler, _viewCompiler: ViewCompiler, _ngModuleCompiler: NgModuleCompiler, _outputEmitter: OutputEmitter, _summaryResolver: SummaryResolver<StaticSymbol>, _localeId: string | null, _translationFormat: string | null, _genFilePreamble: string | null, _symbolResolver: StaticSymbolResolver);
    clearCache(): void;
    compileAll(rootFiles: string[]): Promise<GeneratedFile[]>;
    private _compileSrcFile(srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables);
    private _createSummary(srcFileUrl, directives, pipes, ngModules, injectables, targetStatements, targetExportedVars);
    private _compileModule(ngModuleType, targetStatements);
    private _compileComponentFactory(compMeta, ngModule, fileSuffix, targetStatements);
    private _compileComponent(compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix, targetStatements);
    private _codgenStyles(fileUrl, stylesCompileResult, fileSuffix);
    private _codegenSourceModule(srcFileUrl, genFileUrl, statements, exportedVars);
}
export interface NgAnalyzedModules {
    ngModules: CompileNgModuleMetadata[];
    ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>;
    files: Array<{
        srcUrl: string;
        directives: StaticSymbol[];
        pipes: StaticSymbol[];
        ngModules: StaticSymbol[];
        injectables: StaticSymbol[];
    }>;
    symbolsMissingModule?: StaticSymbol[];
}
export interface NgAnalyzeModulesHost {
    isSourceFile(filePath: string): boolean;
}
export function analyzeNgModules(programStaticSymbols: StaticSymbol[], host: NgAnalyzeModulesHost, metadataResolver: CompileMetadataResolver): NgAnalyzedModules;
export function analyzeAndValidateNgModules(programStaticSymbols: StaticSymbol[], host: NgAnalyzeModulesHost, metadataResolver: CompileMetadataResolver): NgAnalyzedModules;
export function extractProgramSymbols(staticSymbolResolver: StaticSymbolResolver, files: string[], host: NgAnalyzeModulesHost): StaticSymbol[];
}
declare module '@angular/compiler/src/aot/compiler' {
export * from '~@angular/compiler/src/aot/compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/generated_file.d.ts
declare module '~@angular/compiler/src/aot/generated_file' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export class GeneratedFile {
    srcFileUrl: string;
    genFileUrl: string;
    source: string;
    constructor(srcFileUrl: string, genFileUrl: string, source: string);
}
}
declare module '@angular/compiler/src/aot/generated_file' {
export * from '~@angular/compiler/src/aot/generated_file';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/compiler_options.d.ts
declare module '~@angular/compiler/src/aot/compiler_options' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export interface AotCompilerOptions {
    locale?: string;
    i18nFormat?: string;
    translations?: string;
    enableLegacyTemplate?: boolean;
    /** preamble for all generated source files */
    genFilePreamble?: string;
}
}
declare module '@angular/compiler/src/aot/compiler_options' {
export * from '~@angular/compiler/src/aot/compiler_options';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/compiler_host.d.ts
declare module '~@angular/compiler/src/aot/compiler_host' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { StaticSymbolResolverHost } from '~@angular/compiler/src/aot/static_symbol_resolver';
import { AotSummaryResolverHost } from '~@angular/compiler/src/aot/summary_resolver';
/**
 * The host of the AotCompiler disconnects the implementation from TypeScript / other language
 * services and from underlying file systems.
 */
export interface AotCompilerHost extends StaticSymbolResolverHost, AotSummaryResolverHost {
    /**
     * Converts a file path to a module name that can be used as an `import.
     * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.
     *
     * See ImportResolver.
     */
    fileNameToModuleName(importedFilePath: string, containingFilePath: string): string | null;
    /**
     * Loads a resource (e.g. html / css)
     */
    loadResource(path: string): Promise<string>;
}
}
declare module '@angular/compiler/src/aot/compiler_host' {
export * from '~@angular/compiler/src/aot/compiler_host';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/static_reflector.d.ts
declare module '~@angular/compiler/src/aot/static_reflector' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ɵReflectorReader } from '@angular/core';
import { SummaryResolver } from '~@angular/compiler/src/summary_resolver';
import { StaticSymbol } from '~@angular/compiler/src/aot/static_symbol';
import { StaticSymbolResolver } from '~@angular/compiler/src/aot/static_symbol_resolver';
/**
 * A static reflector implements enough of the Reflector API that is necessary to compile
 * templates statically.
 */
export class StaticReflector implements ɵReflectorReader {
    private summaryResolver;
    private symbolResolver;
    private errorRecorder;
    private annotationCache;
    private propertyCache;
    private parameterCache;
    private methodCache;
    private conversionMap;
    private injectionToken;
    private opaqueToken;
    private annotationForParentClassWithSummaryKind;
    private annotationNames;
    constructor(summaryResolver: SummaryResolver<StaticSymbol>, symbolResolver: StaticSymbolResolver, knownMetadataClasses?: {
        name: string;
        filePath: string;
        ctor: any;
    }[], knownMetadataFunctions?: {
        name: string;
        filePath: string;
        fn: any;
    }[], errorRecorder?: (error: any, fileName?: string) => void);
    importUri(typeOrFunc: StaticSymbol): string | null;
    resourceUri(typeOrFunc: StaticSymbol): string;
    resolveIdentifier(name: string, moduleUrl: string, members: string[]): StaticSymbol;
    findDeclaration(moduleUrl: string, name: string, containingFile?: string): StaticSymbol;
    findSymbolDeclaration(symbol: StaticSymbol): StaticSymbol;
    resolveEnum(enumIdentifier: any, name: string): any;
    annotations(type: StaticSymbol): any[];
    propMetadata(type: StaticSymbol): {
        [key: string]: any[];
    };
    parameters(type: StaticSymbol): any[];
    private _methodNames(type);
    private findParentType(type, classMetadata);
    hasLifecycleHook(type: any, lcProperty: string): boolean;
    private _registerDecoratorOrConstructor(type, ctor);
    private _registerFunction(type, fn);
    private initializeConversionMap();
    /**
     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.
     * All types passed to the StaticResolver should be pseudo-types returned by this method.
     *
     * @param declarationFile the absolute path of the file where the symbol is declared
     * @param name the name of the type.
     */
    getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol;
    private reportError(error, context, path?);
    /**
     * Simplify but discard any errors
     */
    private trySimplify(context, value);
    private getTypeMetadata(type);
}
}
declare module '@angular/compiler/src/aot/static_reflector' {
export * from '~@angular/compiler/src/aot/static_reflector';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/static_reflection_capabilities.d.ts
declare module '~@angular/compiler/src/aot/static_reflection_capabilities' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ɵGetterFn, ɵMethodFn, ɵSetterFn } from '@angular/core';
import { StaticReflector } from '~@angular/compiler/src/aot/static_reflector';
import { StaticSymbol } from '~@angular/compiler/src/aot/static_symbol';
export class StaticAndDynamicReflectionCapabilities {
    private staticDelegate;
    static install(staticDelegate: StaticReflector): void;
    private dynamicDelegate;
    constructor(staticDelegate: StaticReflector);
    isReflectionEnabled(): boolean;
    factory(type: any): Function;
    hasLifecycleHook(type: any, lcProperty: string): boolean;
    parameters(type: any): any[][];
    annotations(type: any): any[];
    propMetadata(typeOrFunc: any): {
        [key: string]: any[];
    };
    getter(name: string): ɵGetterFn;
    setter(name: string): ɵSetterFn;
    method(name: string): ɵMethodFn;
    importUri(type: any): string;
    resourceUri(type: any): string;
    resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): StaticSymbol;
    resolveEnum(enumIdentifier: any, name: string): any;
}
}
declare module '@angular/compiler/src/aot/static_reflection_capabilities' {
export * from '~@angular/compiler/src/aot/static_reflection_capabilities';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/static_symbol.d.ts
declare module '~@angular/compiler/src/aot/static_symbol' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A token representing the a reference to a static type.
 *
 * This token is unique for a filePath and name and can be used as a hash table key.
 */
export class StaticSymbol {
    filePath: string;
    name: string;
    members: string[];
    constructor(filePath: string, name: string, members: string[]);
    assertNoMembers(): void;
}
/**
 * A cache of static symbol used by the StaticReflector to return the same symbol for the
 * same symbol values.
 */
export class StaticSymbolCache {
    private cache;
    get(declarationFile: string, name: string, members?: string[]): StaticSymbol;
}
}
declare module '@angular/compiler/src/aot/static_symbol' {
export * from '~@angular/compiler/src/aot/static_symbol';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/static_symbol_resolver.d.ts
declare module '~@angular/compiler/src/aot/static_symbol_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SummaryResolver } from '~@angular/compiler/src/summary_resolver';
import { StaticSymbol, StaticSymbolCache } from '~@angular/compiler/src/aot/static_symbol';
export class ResolvedStaticSymbol {
    symbol: StaticSymbol;
    metadata: any;
    constructor(symbol: StaticSymbol, metadata: any);
}
/**
 * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other
 * language
 * services and from underlying file systems.
 */
export interface StaticSymbolResolverHost {
    /**
     * Return a ModuleMetadata for the given module.
     * Angular CLI will produce this metadata for a module whenever a .d.ts files is
     * produced and the module has exported variables or classes with decorators. Module metadata can
     * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.
     *
     * @param modulePath is a string identifier for a module as an absolute path.
     * @returns the metadata for the given module.
     */
    getMetadataFor(modulePath: string): {
        [key: string]: any;
    }[] | undefined;
    /**
     * Converts a module name that is used in an `import` to a file path.
     * I.e.
     * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.
     */
    moduleNameToFileName(moduleName: string, containingFile?: string): string | null;
}
/**
 * This class is responsible for loading metadata per symbol,
 * and normalizing references between symbols.
 *
 * Internally, it only uses symbols without members,
 * and deduces the values for symbols with members based
 * on these symbols.
 */
export class StaticSymbolResolver {
    private host;
    private staticSymbolCache;
    private summaryResolver;
    private errorRecorder;
    private metadataCache;
    private resolvedSymbols;
    private resolvedFilePaths;
    private importAs;
    private symbolResourcePaths;
    private symbolFromFile;
    constructor(host: StaticSymbolResolverHost, staticSymbolCache: StaticSymbolCache, summaryResolver: SummaryResolver<StaticSymbol>, errorRecorder?: (error: any, fileName?: string) => void);
    resolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol;
    /**
     * getImportAs produces a symbol that can be used to import the given symbol.
     * The import might be different than the symbol if the symbol is exported from
     * a library with a summary; in which case we want to import the symbol from the
     * ngfactory re-export instead of directly to avoid introducing a direct dependency
     * on an otherwise indirect dependency.
     *
     * @param staticSymbol the symbol for which to generate a import symbol
     */
    getImportAs(staticSymbol: StaticSymbol): StaticSymbol | null;
    /**
     * getResourcePath produces the path to the original location of the symbol and should
     * be used to determine the relative location of resource references recorded in
     * symbol metadata.
     */
    getResourcePath(staticSymbol: StaticSymbol): string;
    /**
     * getTypeArity returns the number of generic type parameters the given symbol
     * has. If the symbol is not a type the result is null.
     */
    getTypeArity(staticSymbol: StaticSymbol): number | null;
    recordImportAs(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol): void;
    /**
     * Invalidate all information derived from the given file.
     *
     * @param fileName the file to invalidate
     */
    invalidateFile(fileName: string): void;
    private _resolveSymbolMembers(staticSymbol);
    private _resolveSymbolFromSummary(staticSymbol);
    /**
     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.
     * All types passed to the StaticResolver should be pseudo-types returned by this method.
     *
     * @param declarationFile the absolute path of the file where the symbol is declared
     * @param name the name of the type.
     * @param members a symbol for a static member of the named type
     */
    getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol;
    getSymbolsOf(filePath: string): StaticSymbol[];
    private _createSymbolsOf(filePath);
    private createResolvedSymbol(sourceSymbol, topLevelPath, topLevelSymbolNames, metadata);
    private createExport(sourceSymbol, targetSymbol);
    private reportError(error, context?, path?);
    /**
     * @param module an absolute path to a module file.
     */
    private getModuleMetadata(module);
    getSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol;
    private resolveModule(module, containingFile?);
}
export function unescapeIdentifier(identifier: string): string;
}
declare module '@angular/compiler/src/aot/static_symbol_resolver' {
export * from '~@angular/compiler/src/aot/static_symbol_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/summary_resolver.d.ts
declare module '~@angular/compiler/src/aot/summary_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Summary, SummaryResolver } from '~@angular/compiler/src/summary_resolver';
import { StaticSymbol, StaticSymbolCache } from '~@angular/compiler/src/aot/static_symbol';
export interface AotSummaryResolverHost {
    /**
     * Loads an NgModule/Directive/Pipe summary file
     */
    loadSummary(filePath: string): string | null;
    /**
     * Returns whether a file is a source file or not.
     */
    isSourceFile(sourceFilePath: string): boolean;
    /**
     * Returns the output file path of a source file.
     * E.g.
     * `some_file.ts` -> `some_file.d.ts`
     */
    getOutputFileName(sourceFilePath: string): string;
}
export class AotSummaryResolver implements SummaryResolver<StaticSymbol> {
    private host;
    private staticSymbolCache;
    private summaryCache;
    private loadedFilePaths;
    private importAs;
    constructor(host: AotSummaryResolverHost, staticSymbolCache: StaticSymbolCache);
    isLibraryFile(filePath: string): boolean;
    getLibraryFileName(filePath: string): string;
    resolveSummary(staticSymbol: StaticSymbol): Summary<StaticSymbol>;
    getSymbolsOf(filePath: string): StaticSymbol[];
    getImportAs(staticSymbol: StaticSymbol): StaticSymbol;
    private _loadSummaryFile(filePath);
}
}
declare module '@angular/compiler/src/aot/summary_resolver' {
export * from '~@angular/compiler/src/aot/summary_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/summary_resolver.d.ts
declare module '~@angular/compiler/src/summary_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileTypeSummary } from '~@angular/compiler/src/compile_metadata';
export interface Summary<T> {
    symbol: T;
    metadata: any;
    type?: CompileTypeSummary;
}
export class SummaryResolver<T> {
    isLibraryFile(fileName: string): boolean;
    getLibraryFileName(fileName: string): string | null;
    resolveSummary(reference: T): Summary<T> | null;
    getSymbolsOf(filePath: string): T[];
    getImportAs(reference: T): T;
}
}
declare module '@angular/compiler/src/summary_resolver' {
export * from '~@angular/compiler/src/summary_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/jit/compiler.d.ts
declare module '~@angular/compiler/src/jit/compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Compiler, Injector, ModuleWithComponentFactories, NgModuleFactory, Type, ɵConsole as Console } from '@angular/core';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { CompileMetadataResolver } from '~@angular/compiler/src/metadata_resolver';
import { NgModuleCompiler } from '~@angular/compiler/src/ng_module_compiler';
import { StyleCompiler } from '~@angular/compiler/src/style_compiler';
import { TemplateParser } from '~@angular/compiler/src/template_parser/template_parser';
import { ViewCompiler } from '~@angular/compiler/src/view_compiler/view_compiler';
/**
 * An internal module of the Angular compiler that begins with component types,
 * extracts templates, and eventually produces a compiled version of the component
 * ready for linking into an application.
 *
 * @security  When compiling templates at runtime, you must ensure that the entire template comes
 * from a trusted source. Attacker-controlled data introduced by a template could expose your
 * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).
 */
export class JitCompiler implements Compiler {
    private _injector;
    private _metadataResolver;
    private _templateParser;
    private _styleCompiler;
    private _viewCompiler;
    private _ngModuleCompiler;
    private _compilerConfig;
    private _console;
    private _compiledTemplateCache;
    private _compiledHostTemplateCache;
    private _compiledDirectiveWrapperCache;
    private _compiledNgModuleCache;
    private _sharedStylesheetCount;
    constructor(_injector: Injector, _metadataResolver: CompileMetadataResolver, _templateParser: TemplateParser, _styleCompiler: StyleCompiler, _viewCompiler: ViewCompiler, _ngModuleCompiler: NgModuleCompiler, _compilerConfig: CompilerConfig, _console: Console);
    readonly injector: Injector;
    compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;
    compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;
    compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;
    compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;
    getNgContentSelectors(component: Type<any>): string[];
    private _compileModuleAndComponents<T>(moduleType, isSync);
    private _compileModuleAndAllComponents<T>(moduleType, isSync);
    private _loadModules(mainModule, isSync);
    private _compileModule<T>(moduleType);
    clearCacheFor(type: Type<any>): void;
    clearCache(): void;
    private _createCompiledHostTemplate(compType, ngModule);
    private _createCompiledTemplate(compMeta, ngModule);
    private _compileTemplate(template);
    private _resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
    private _resolveAndEvalStylesCompileResult(result, externalStylesheetsByModuleUrl);
}
}
declare module '@angular/compiler/src/jit/compiler' {
export * from '~@angular/compiler/src/jit/compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/jit/compiler_factory.d.ts
declare module '~@angular/compiler/src/jit/compiler_factory' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Compiler, CompilerFactory, CompilerOptions, PlatformRef, Provider, Type, ɵConsole as Console } from '@angular/core';
import { CompilerConfig } from '~@angular/compiler/src/config';
import * as i18n from '~@angular/compiler/src/i18n/index';
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
export function i18nHtmlParserFactory(parser: HtmlParser, translations: string, format: string, config: CompilerConfig, console: Console): i18n.I18NHtmlParser;
/**
 * A set of providers that provide `JitCompiler` and its dependencies to use for
 * template compilation.
 */
export const COMPILER_PROVIDERS: Array<any | Type<any> | {
    [k: string]: any;
} | any[]>;
export class JitCompilerFactory implements CompilerFactory {
    private _defaultOptions;
    constructor(defaultOptions: CompilerOptions[]);
    createCompiler(options?: CompilerOptions[]): Compiler;
}
/**
 * A platform that included corePlatform and the compiler.
 *
 * @experimental
 */
export const platformCoreDynamic: (extraProviders?: Provider[] | undefined) => PlatformRef;
}
declare module '@angular/compiler/src/jit/compiler_factory' {
export * from '~@angular/compiler/src/jit/compiler_factory';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/url_resolver.d.ts
declare module '~@angular/compiler/src/url_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { InjectionToken } from '@angular/core';
/**
 * Create a {@link UrlResolver} with no package prefix.
 */
export function createUrlResolverWithoutPackagePrefix(): UrlResolver;
export function createOfflineCompileUrlResolver(): UrlResolver;
/**
 * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.
 */
export const DEFAULT_PACKAGE_URL_PROVIDER: {
    provide: InjectionToken<string>;
    useValue: string;
};
/**
 * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
 *
 * This class can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 *
 * ## Example
 *
 * {@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}
 *
 * @security  When compiling templates at runtime, you must
 * ensure that the entire template comes from a trusted source.
 * Attacker-controlled data introduced by a template could expose your
 * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
 */
export class UrlResolver {
    private _packagePrefix;
    constructor(_packagePrefix?: string | null);
    /**
     * Resolves the `url` given the `baseUrl`:
     * - when the `url` is null, the `baseUrl` is returned,
     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
     * `baseUrl` and `url`,
     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
     * returned as is (ignoring the `baseUrl`)
     */
    resolve(baseUrl: string, url: string): string;
}
/**
 * Extract the scheme of a URL.
 */
export function getUrlScheme(url: string): string;
}
declare module '@angular/compiler/src/url_resolver' {
export * from '~@angular/compiler/src/url_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/resource_loader.d.ts
declare module '~@angular/compiler/src/resource_loader' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An interface for retrieving documents by URL that the compiler uses
 * to load templates.
 */
export class ResourceLoader {
    get(url: string): Promise<string> | null;
}
}
declare module '@angular/compiler/src/resource_loader' {
export * from '~@angular/compiler/src/resource_loader';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/directive_resolver.d.ts
declare module '~@angular/compiler/src/directive_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, Type, ɵReflectorReader } from '@angular/core';
export class DirectiveResolver {
    private _reflector;
    constructor(_reflector?: ɵReflectorReader);
    isDirective(type: Type<any>): boolean;
    /**
     * Return {@link Directive} for a given `Type`.
     */
    resolve(type: Type<any>): Directive;
    resolve(type: Type<any>, throwIfNotFound: true): Directive;
    resolve(type: Type<any>, throwIfNotFound: boolean): Directive | null;
    private _mergeWithPropertyMetadata(dm, propertyMetadata, directiveType);
    private _extractPublicName(def);
    private _dedupeBindings(bindings);
    private _merge(directive, inputs, outputs, host, queries, directiveType);
}
export function findLast<T>(arr: T[], condition: (value: T) => boolean): T | null;
}
declare module '@angular/compiler/src/directive_resolver' {
export * from '~@angular/compiler/src/directive_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/pipe_resolver.d.ts
declare module '~@angular/compiler/src/pipe_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Pipe, Type, ɵReflectorReader } from '@angular/core';
/**
 * Resolve a `Type` for {@link Pipe}.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
export class PipeResolver {
    private _reflector;
    constructor(_reflector?: ɵReflectorReader);
    isPipe(type: Type<any>): boolean;
    /**
     * Return {@link Pipe} for a given `Type`.
     */
    resolve(type: Type<any>, throwIfNotFound?: boolean): Pipe | null;
}
}
declare module '@angular/compiler/src/pipe_resolver' {
export * from '~@angular/compiler/src/pipe_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ng_module_resolver.d.ts
declare module '~@angular/compiler/src/ng_module_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NgModule, Type, ɵReflectorReader } from '@angular/core';
/**
 * Resolves types to {@link NgModule}.
 */
export class NgModuleResolver {
    private _reflector;
    constructor(_reflector?: ɵReflectorReader);
    isNgModule(type: any): boolean;
    resolve(type: Type<any>, throwIfNotFound?: boolean): NgModule | null;
}
}
declare module '@angular/compiler/src/ng_module_resolver' {
export * from '~@angular/compiler/src/ng_module_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/interpolation_config.d.ts
declare module '~@angular/compiler/src/ml_parser/interpolation_config' {
export class InterpolationConfig {
    start: string;
    end: string;
    static fromArray(markers: [string, string] | null): InterpolationConfig;
    constructor(start: string, end: string);
}
export const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig;
}
declare module '@angular/compiler/src/ml_parser/interpolation_config' {
export * from '~@angular/compiler/src/ml_parser/interpolation_config';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/schema/element_schema_registry.d.ts
declare module '~@angular/compiler/src/schema/element_schema_registry' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SchemaMetadata, SecurityContext } from '@angular/core';
export abstract class ElementSchemaRegistry {
    abstract hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;
    abstract hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;
    abstract securityContext(elementName: string, propName: string, isAttribute: boolean): SecurityContext;
    abstract allKnownElementNames(): string[];
    abstract getMappedPropName(propName: string): string;
    abstract getDefaultComponentElementName(): string;
    abstract validateProperty(name: string): {
        error: boolean;
        msg?: string;
    };
    abstract validateAttribute(name: string): {
        error: boolean;
        msg?: string;
    };
    abstract normalizeAnimationStyleProperty(propName: string): string;
    abstract normalizeAnimationStyleValue(camelCaseProp: string, userProvidedProp: string, val: string | number): {
        error: string;
        value: string;
    };
}
}
declare module '@angular/compiler/src/schema/element_schema_registry' {
export * from '~@angular/compiler/src/schema/element_schema_registry';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/extractor.d.ts
declare module '~@angular/compiler/src/i18n/extractor' {
import { StaticReflector } from '~@angular/compiler/src/aot/static_reflector';
import { StaticSymbolResolver, StaticSymbolResolverHost } from '~@angular/compiler/src/aot/static_symbol_resolver';
import { AotSummaryResolverHost } from '~@angular/compiler/src/aot/summary_resolver';
import { CompileMetadataResolver } from '~@angular/compiler/src/metadata_resolver';
import { MessageBundle } from '~@angular/compiler/src/i18n/message_bundle';
/**
 * The host of the Extractor disconnects the implementation from TypeScript / other language
 * services and from underlying file systems.
 */
export interface ExtractorHost extends StaticSymbolResolverHost, AotSummaryResolverHost {
    /**
     * Loads a resource (e.g. html / css)
     */
    loadResource(path: string): Promise<string>;
}
export class Extractor {
    host: ExtractorHost;
    private staticSymbolResolver;
    private messageBundle;
    private metadataResolver;
    constructor(host: ExtractorHost, staticSymbolResolver: StaticSymbolResolver, messageBundle: MessageBundle, metadataResolver: CompileMetadataResolver);
    extract(rootFiles: string[]): Promise<MessageBundle>;
    static create(host: ExtractorHost, locale: string | null): {
        extractor: Extractor;
        staticReflector: StaticReflector;
    };
}
}
declare module '@angular/compiler/src/i18n/extractor' {
export * from '~@angular/compiler/src/i18n/extractor';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/i18n_ast.d.ts
declare module '~@angular/compiler/src/i18n/i18n_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
export class Message {
    nodes: Node[];
    placeholders: {
        [phName: string]: string;
    };
    placeholderToMessage: {
        [phName: string]: Message;
    };
    meaning: string;
    description: string;
    id: string;
    sources: MessageSpan[];
    /**
     * @param nodes message AST
     * @param placeholders maps placeholder names to static content
     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)
     * @param meaning
     * @param description
     * @param id
     */
    constructor(nodes: Node[], placeholders: {
        [phName: string]: string;
    }, placeholderToMessage: {
        [phName: string]: Message;
    }, meaning: string, description: string, id: string);
}
export interface MessageSpan {
    filePath: string;
    startLine: number;
    startCol: number;
    endLine: number;
    endCol: number;
}
export interface Node {
    sourceSpan: ParseSourceSpan;
    visit(visitor: Visitor, context?: any): any;
}
export class Text implements Node {
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class Container implements Node {
    children: Node[];
    sourceSpan: ParseSourceSpan;
    constructor(children: Node[], sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class Icu implements Node {
    expression: string;
    type: string;
    cases: {
        [k: string]: Node;
    };
    sourceSpan: ParseSourceSpan;
    expressionPlaceholder: string;
    constructor(expression: string, type: string, cases: {
        [k: string]: Node;
    }, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class TagPlaceholder implements Node {
    tag: string;
    attrs: {
        [k: string]: string;
    };
    startName: string;
    closeName: string;
    children: Node[];
    isVoid: boolean;
    sourceSpan: ParseSourceSpan;
    constructor(tag: string, attrs: {
        [k: string]: string;
    }, startName: string, closeName: string, children: Node[], isVoid: boolean, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class Placeholder implements Node {
    value: string;
    name: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, name: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class IcuPlaceholder implements Node {
    value: Icu;
    name: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: Icu, name: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export interface Visitor {
    visitText(text: Text, context?: any): any;
    visitContainer(container: Container, context?: any): any;
    visitIcu(icu: Icu, context?: any): any;
    visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;
    visitPlaceholder(ph: Placeholder, context?: any): any;
    visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;
}
export class CloneVisitor implements Visitor {
    visitText(text: Text, context?: any): Text;
    visitContainer(container: Container, context?: any): Container;
    visitIcu(icu: Icu, context?: any): Icu;
    visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder;
    visitPlaceholder(ph: Placeholder, context?: any): Placeholder;
    visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder;
}
export class RecurseVisitor implements Visitor {
    visitText(text: Text, context?: any): any;
    visitContainer(container: Container, context?: any): any;
    visitIcu(icu: Icu, context?: any): any;
    visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;
    visitPlaceholder(ph: Placeholder, context?: any): any;
    visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;
}
}
declare module '@angular/compiler/src/i18n/i18n_ast' {
export * from '~@angular/compiler/src/i18n/i18n_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/message_bundle.d.ts
declare module '~@angular/compiler/src/i18n/message_bundle' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseError } from '~@angular/compiler/src/parse_util';
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
/**
 * A container for message extracted from the templates.
 */
export class MessageBundle {
    private _htmlParser;
    private _implicitTags;
    private _implicitAttrs;
    private _locale;
    private _messages;
    constructor(_htmlParser: HtmlParser, _implicitTags: string[], _implicitAttrs: {
        [k: string]: string[];
    }, _locale?: string | null);
    updateFromTemplate(html: string, url: string, interpolationConfig: InterpolationConfig): ParseError[];
    getMessages(): i18n.Message[];
    write(serializer: Serializer, filterSources?: (path: string) => string): string;
}
}
declare module '@angular/compiler/src/i18n/message_bundle' {
export * from '~@angular/compiler/src/i18n/message_bundle';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/serializer.d.ts
declare module '~@angular/compiler/src/i18n/serializers/serializer' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
export abstract class Serializer {
    abstract write(messages: i18n.Message[], locale: string | null): string;
    abstract load(content: string, url: string): {
        locale: string | null;
        i18nNodesByMsgId: {
            [msgId: string]: i18n.Node[];
        };
    };
    abstract digest(message: i18n.Message): string;
    createNameMapper(message: i18n.Message): PlaceholderMapper | null;
}
/**
 * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and
 * back.
 *
 * It should be used for serialization format that put constraints on the placeholder names.
 */
export interface PlaceholderMapper {
    toPublicName(internalName: string): string | null;
    toInternalName(publicName: string): string | null;
}
/**
 * A simple mapper that take a function to transform an internal name to a public name
 */
export class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {
    private mapName;
    private internalToPublic;
    private publicToNextId;
    private publicToInternal;
    constructor(message: i18n.Message, mapName: (name: string) => string);
    toPublicName(internalName: string): string | null;
    toInternalName(publicName: string): string | null;
    visitText(text: i18n.Text, context?: any): any;
    visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any;
    visitPlaceholder(ph: i18n.Placeholder, context?: any): any;
    visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any;
    private visitPlaceholderName(internalName);
}
}
declare module '@angular/compiler/src/i18n/serializers/serializer' {
export * from '~@angular/compiler/src/i18n/serializers/serializer';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/xliff.d.ts
declare module '~@angular/compiler/src/i18n/serializers/xliff' {
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export class Xliff extends Serializer {
    write(messages: i18n.Message[], locale: string | null): string;
    load(content: string, url: string): {
        locale: string;
        i18nNodesByMsgId: {
            [msgId: string]: i18n.Node[];
        };
    };
    digest(message: i18n.Message): string;
}
}
declare module '@angular/compiler/src/i18n/serializers/xliff' {
export * from '~@angular/compiler/src/i18n/serializers/xliff';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/xliff2.d.ts
declare module '~@angular/compiler/src/i18n/serializers/xliff2' {
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export class Xliff2 extends Serializer {
    write(messages: i18n.Message[], locale: string | null): string;
    load(content: string, url: string): {
        locale: string;
        i18nNodesByMsgId: {
            [msgId: string]: i18n.Node[];
        };
    };
    digest(message: i18n.Message): string;
}
}
declare module '@angular/compiler/src/i18n/serializers/xliff2' {
export * from '~@angular/compiler/src/i18n/serializers/xliff2';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/xmb.d.ts
declare module '~@angular/compiler/src/i18n/serializers/xmb' {
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { PlaceholderMapper, Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export class Xmb extends Serializer {
    write(messages: i18n.Message[], locale: string | null): string;
    load(content: string, url: string): {
        locale: string;
        i18nNodesByMsgId: {
            [msgId: string]: i18n.Node[];
        };
    };
    digest(message: i18n.Message): string;
    createNameMapper(message: i18n.Message): PlaceholderMapper;
}
export function digest(message: i18n.Message): string;
export function toPublicName(internalName: string): string;
}
declare module '@angular/compiler/src/i18n/serializers/xmb' {
export * from '~@angular/compiler/src/i18n/serializers/xmb';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/xtb.d.ts
declare module '~@angular/compiler/src/i18n/serializers/xtb' {
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { PlaceholderMapper, Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export class Xtb extends Serializer {
    write(messages: i18n.Message[], locale: string | null): string;
    load(content: string, url: string): {
        locale: string;
        i18nNodesByMsgId: {
            [msgId: string]: i18n.Node[];
        };
    };
    digest(message: i18n.Message): string;
    createNameMapper(message: i18n.Message): PlaceholderMapper;
}
}
declare module '@angular/compiler/src/i18n/serializers/xtb' {
export * from '~@angular/compiler/src/i18n/serializers/xtb';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/index.d.ts
declare module '~@angular/compiler/src/i18n/index' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { Extractor, ExtractorHost } from '~@angular/compiler/src/i18n/extractor';
export { I18NHtmlParser } from '~@angular/compiler/src/i18n/i18n_html_parser';
export { MessageBundle } from '~@angular/compiler/src/i18n/message_bundle';
export { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export { Xliff } from '~@angular/compiler/src/i18n/serializers/xliff';
export { Xliff2 } from '~@angular/compiler/src/i18n/serializers/xliff2';
export { Xmb } from '~@angular/compiler/src/i18n/serializers/xmb';
export { Xtb } from '~@angular/compiler/src/i18n/serializers/xtb';
}
declare module '@angular/compiler/src/i18n/index' {
export * from '~@angular/compiler/src/i18n/index';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/directive_normalizer.d.ts
declare module '~@angular/compiler/src/directive_normalizer' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ViewEncapsulation } from '@angular/core';
import { CompileAnimationEntryMetadata, CompileDirectiveMetadata, CompileStylesheetMetadata, CompileTemplateMetadata } from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { ResourceLoader } from '~@angular/compiler/src/resource_loader';
import { UrlResolver } from '~@angular/compiler/src/url_resolver';
import { SyncAsyncResult } from '~@angular/compiler/src/util';
export interface PrenormalizedTemplateMetadata {
    ngModuleType: any;
    componentType: any;
    moduleUrl: string;
    template: string | null;
    templateUrl: string | null;
    styles: string[];
    styleUrls: string[];
    interpolation: [string, string] | null;
    encapsulation: ViewEncapsulation | null;
    animations: CompileAnimationEntryMetadata[];
}
export class DirectiveNormalizer {
    private _resourceLoader;
    private _urlResolver;
    private _htmlParser;
    private _config;
    private _resourceLoaderCache;
    constructor(_resourceLoader: ResourceLoader, _urlResolver: UrlResolver, _htmlParser: HtmlParser, _config: CompilerConfig);
    clearCache(): void;
    clearCacheFor(normalizedDirective: CompileDirectiveMetadata): void;
    private _fetch(url);
    normalizeTemplate(prenormData: PrenormalizedTemplateMetadata): SyncAsyncResult<CompileTemplateMetadata>;
    normalizeTemplateSync(prenomData: PrenormalizedTemplateMetadata): CompileTemplateMetadata;
    normalizeTemplateAsync(prenomData: PrenormalizedTemplateMetadata): Promise<CompileTemplateMetadata>;
    normalizeLoadedTemplate(prenormData: PrenormalizedTemplateMetadata, template: string, templateAbsUrl: string): CompileTemplateMetadata;
    normalizeExternalStylesheets(templateMeta: CompileTemplateMetadata): Promise<CompileTemplateMetadata>;
    private _loadMissingExternalStylesheets(styleUrls, loadedStylesheets?);
    normalizeStylesheet(stylesheet: CompileStylesheetMetadata): CompileStylesheetMetadata;
}
}
declare module '@angular/compiler/src/directive_normalizer' {
export * from '~@angular/compiler/src/directive_normalizer';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/expression_parser/ast.d.ts
declare module '~@angular/compiler/src/expression_parser/ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export class ParserError {
    input: string;
    errLocation: string;
    ctxLocation: any;
    message: string;
    constructor(message: string, input: string, errLocation: string, ctxLocation?: any);
}
export class ParseSpan {
    start: number;
    end: number;
    constructor(start: number, end: number);
}
export class AST {
    span: ParseSpan;
    constructor(span: ParseSpan);
    visit(visitor: AstVisitor, context?: any): any;
    toString(): string;
}
/**
 * Represents a quoted expression of the form:
 *
 * quote = prefix `:` uninterpretedExpression
 * prefix = identifier
 * uninterpretedExpression = arbitrary string
 *
 * A quoted expression is meant to be pre-processed by an AST transformer that
 * converts it into another AST that no longer contains quoted expressions.
 * It is meant to allow third-party developers to extend Angular template
 * expression language. The `uninterpretedExpression` part of the quote is
 * therefore not interpreted by the Angular's own expression parser.
 */
export class Quote extends AST {
    prefix: string;
    uninterpretedExpression: string;
    location: any;
    constructor(span: ParseSpan, prefix: string, uninterpretedExpression: string, location: any);
    visit(visitor: AstVisitor, context?: any): any;
    toString(): string;
}
export class EmptyExpr extends AST {
    visit(visitor: AstVisitor, context?: any): void;
}
export class ImplicitReceiver extends AST {
    visit(visitor: AstVisitor, context?: any): any;
}
/**
 * Multiple expressions separated by a semicolon.
 */
export class Chain extends AST {
    expressions: any[];
    constructor(span: ParseSpan, expressions: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class Conditional extends AST {
    condition: AST;
    trueExp: AST;
    falseExp: AST;
    constructor(span: ParseSpan, condition: AST, trueExp: AST, falseExp: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class PropertyRead extends AST {
    receiver: AST;
    name: string;
    constructor(span: ParseSpan, receiver: AST, name: string);
    visit(visitor: AstVisitor, context?: any): any;
}
export class PropertyWrite extends AST {
    receiver: AST;
    name: string;
    value: AST;
    constructor(span: ParseSpan, receiver: AST, name: string, value: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class SafePropertyRead extends AST {
    receiver: AST;
    name: string;
    constructor(span: ParseSpan, receiver: AST, name: string);
    visit(visitor: AstVisitor, context?: any): any;
}
export class KeyedRead extends AST {
    obj: AST;
    key: AST;
    constructor(span: ParseSpan, obj: AST, key: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class KeyedWrite extends AST {
    obj: AST;
    key: AST;
    value: AST;
    constructor(span: ParseSpan, obj: AST, key: AST, value: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class BindingPipe extends AST {
    exp: AST;
    name: string;
    args: any[];
    constructor(span: ParseSpan, exp: AST, name: string, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class LiteralPrimitive extends AST {
    value: any;
    constructor(span: ParseSpan, value: any);
    visit(visitor: AstVisitor, context?: any): any;
}
export class LiteralArray extends AST {
    expressions: any[];
    constructor(span: ParseSpan, expressions: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class LiteralMap extends AST {
    keys: any[];
    values: any[];
    constructor(span: ParseSpan, keys: any[], values: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class Interpolation extends AST {
    strings: any[];
    expressions: any[];
    constructor(span: ParseSpan, strings: any[], expressions: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class Binary extends AST {
    operation: string;
    left: AST;
    right: AST;
    constructor(span: ParseSpan, operation: string, left: AST, right: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class PrefixNot extends AST {
    expression: AST;
    constructor(span: ParseSpan, expression: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class MethodCall extends AST {
    receiver: AST;
    name: string;
    args: any[];
    constructor(span: ParseSpan, receiver: AST, name: string, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class SafeMethodCall extends AST {
    receiver: AST;
    name: string;
    args: any[];
    constructor(span: ParseSpan, receiver: AST, name: string, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class FunctionCall extends AST {
    target: AST | null;
    args: any[];
    constructor(span: ParseSpan, target: AST | null, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class ASTWithSource extends AST {
    ast: AST;
    source: string | null;
    location: string;
    errors: ParserError[];
    constructor(ast: AST, source: string | null, location: string, errors: ParserError[]);
    visit(visitor: AstVisitor, context?: any): any;
    toString(): string;
}
export class TemplateBinding {
    span: ParseSpan;
    key: string;
    keyIsVar: boolean;
    name: string;
    expression: ASTWithSource;
    constructor(span: ParseSpan, key: string, keyIsVar: boolean, name: string, expression: ASTWithSource);
}
export interface AstVisitor {
    visitBinary(ast: Binary, context: any): any;
    visitChain(ast: Chain, context: any): any;
    visitConditional(ast: Conditional, context: any): any;
    visitFunctionCall(ast: FunctionCall, context: any): any;
    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;
    visitInterpolation(ast: Interpolation, context: any): any;
    visitKeyedRead(ast: KeyedRead, context: any): any;
    visitKeyedWrite(ast: KeyedWrite, context: any): any;
    visitLiteralArray(ast: LiteralArray, context: any): any;
    visitLiteralMap(ast: LiteralMap, context: any): any;
    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;
    visitMethodCall(ast: MethodCall, context: any): any;
    visitPipe(ast: BindingPipe, context: any): any;
    visitPrefixNot(ast: PrefixNot, context: any): any;
    visitPropertyRead(ast: PropertyRead, context: any): any;
    visitPropertyWrite(ast: PropertyWrite, context: any): any;
    visitQuote(ast: Quote, context: any): any;
    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;
    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;
}
export class RecursiveAstVisitor implements AstVisitor {
    visitBinary(ast: Binary, context: any): any;
    visitChain(ast: Chain, context: any): any;
    visitConditional(ast: Conditional, context: any): any;
    visitPipe(ast: BindingPipe, context: any): any;
    visitFunctionCall(ast: FunctionCall, context: any): any;
    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;
    visitInterpolation(ast: Interpolation, context: any): any;
    visitKeyedRead(ast: KeyedRead, context: any): any;
    visitKeyedWrite(ast: KeyedWrite, context: any): any;
    visitLiteralArray(ast: LiteralArray, context: any): any;
    visitLiteralMap(ast: LiteralMap, context: any): any;
    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;
    visitMethodCall(ast: MethodCall, context: any): any;
    visitPrefixNot(ast: PrefixNot, context: any): any;
    visitPropertyRead(ast: PropertyRead, context: any): any;
    visitPropertyWrite(ast: PropertyWrite, context: any): any;
    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;
    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;
    visitAll(asts: AST[], context: any): any;
    visitQuote(ast: Quote, context: any): any;
}
export class AstTransformer implements AstVisitor {
    visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST;
    visitInterpolation(ast: Interpolation, context: any): AST;
    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST;
    visitPropertyRead(ast: PropertyRead, context: any): AST;
    visitPropertyWrite(ast: PropertyWrite, context: any): AST;
    visitSafePropertyRead(ast: SafePropertyRead, context: any): AST;
    visitMethodCall(ast: MethodCall, context: any): AST;
    visitSafeMethodCall(ast: SafeMethodCall, context: any): AST;
    visitFunctionCall(ast: FunctionCall, context: any): AST;
    visitLiteralArray(ast: LiteralArray, context: any): AST;
    visitLiteralMap(ast: LiteralMap, context: any): AST;
    visitBinary(ast: Binary, context: any): AST;
    visitPrefixNot(ast: PrefixNot, context: any): AST;
    visitConditional(ast: Conditional, context: any): AST;
    visitPipe(ast: BindingPipe, context: any): AST;
    visitKeyedRead(ast: KeyedRead, context: any): AST;
    visitKeyedWrite(ast: KeyedWrite, context: any): AST;
    visitAll(asts: any[]): any[];
    visitChain(ast: Chain, context: any): AST;
    visitQuote(ast: Quote, context: any): AST;
}
}
declare module '@angular/compiler/src/expression_parser/ast' {
export * from '~@angular/compiler/src/expression_parser/ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/expression_parser/lexer.d.ts
declare module '~@angular/compiler/src/expression_parser/lexer' {
export enum TokenType {
    Character = 0,
    Identifier = 1,
    Keyword = 2,
    String = 3,
    Operator = 4,
    Number = 5,
    Error = 6,
}
export class Lexer {
    tokenize(text: string): Token[];
}
export class Token {
    index: number;
    type: TokenType;
    numValue: number;
    strValue: string;
    constructor(index: number, type: TokenType, numValue: number, strValue: string);
    isCharacter(code: number): boolean;
    isNumber(): boolean;
    isString(): boolean;
    isOperator(operater: string): boolean;
    isIdentifier(): boolean;
    isKeyword(): boolean;
    isKeywordLet(): boolean;
    isKeywordAs(): boolean;
    isKeywordNull(): boolean;
    isKeywordUndefined(): boolean;
    isKeywordTrue(): boolean;
    isKeywordFalse(): boolean;
    isKeywordThis(): boolean;
    isError(): boolean;
    toNumber(): number;
    toString(): string | null;
}
export const EOF: Token;
export function isIdentifier(input: string): boolean;
export function isQuote(code: number): boolean;
}
declare module '@angular/compiler/src/expression_parser/lexer' {
export * from '~@angular/compiler/src/expression_parser/lexer';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/expression_parser/parser.d.ts
declare module '~@angular/compiler/src/expression_parser/parser' {
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { AST, ASTWithSource, BindingPipe, LiteralMap, ParseSpan, ParserError, TemplateBinding } from '~@angular/compiler/src/expression_parser/ast';
import { Lexer, Token } from '~@angular/compiler/src/expression_parser/lexer';
export class SplitInterpolation {
    strings: string[];
    expressions: string[];
    offsets: number[];
    constructor(strings: string[], expressions: string[], offsets: number[]);
}
export class TemplateBindingParseResult {
    templateBindings: TemplateBinding[];
    warnings: string[];
    errors: ParserError[];
    constructor(templateBindings: TemplateBinding[], warnings: string[], errors: ParserError[]);
}
export class Parser {
    private _lexer;
    private errors;
    constructor(_lexer: Lexer);
    parseAction(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;
    parseBinding(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;
    parseSimpleBinding(input: string, location: string, interpolationConfig?: InterpolationConfig): ASTWithSource;
    private _reportError(message, input, errLocation, ctxLocation?);
    private _parseBindingAst(input, location, interpolationConfig);
    private _parseQuote(input, location);
    parseTemplateBindings(prefixToken: string | null, input: string, location: any): TemplateBindingParseResult;
    parseInterpolation(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource | null;
    splitInterpolation(input: string, location: string, interpolationConfig?: InterpolationConfig): SplitInterpolation | null;
    wrapLiteralPrimitive(input: string | null, location: any): ASTWithSource;
    private _stripComments(input);
    private _commentStart(input);
    private _checkNoInterpolation(input, location, interpolationConfig);
    private _findInterpolationErrorColumn(parts, partInErrIdx, interpolationConfig);
}
export class _ParseAST {
    input: string;
    location: any;
    tokens: Token[];
    inputLength: number;
    parseAction: boolean;
    private errors;
    private offset;
    private rparensExpected;
    private rbracketsExpected;
    private rbracesExpected;
    index: number;
    constructor(input: string, location: any, tokens: Token[], inputLength: number, parseAction: boolean, errors: ParserError[], offset: number);
    peek(offset: number): Token;
    readonly next: Token;
    readonly inputIndex: number;
    span(start: number): ParseSpan;
    advance(): void;
    optionalCharacter(code: number): boolean;
    peekKeywordLet(): boolean;
    peekKeywordAs(): boolean;
    expectCharacter(code: number): void;
    optionalOperator(op: string): boolean;
    expectOperator(operator: string): void;
    expectIdentifierOrKeyword(): string | null;
    expectIdentifierOrKeywordOrString(): string | null;
    parseChain(): AST;
    parsePipe(): AST;
    parseExpression(): AST;
    parseConditional(): AST;
    parseLogicalOr(): AST;
    parseLogicalAnd(): AST;
    parseEquality(): AST;
    parseRelational(): AST;
    parseAdditive(): AST;
    parseMultiplicative(): AST;
    parsePrefix(): AST;
    parseCallChain(): AST;
    parsePrimary(): AST;
    parseExpressionList(terminator: number): AST[];
    parseLiteralMap(): LiteralMap;
    parseAccessMemberOrMethodCall(receiver: AST, isSafe?: boolean): AST;
    parseCallArguments(): BindingPipe[];
    /**
     * An identifier, a keyword, a string with an optional `-` inbetween.
     */
    expectTemplateBindingKey(): string;
    parseTemplateBindings(): TemplateBindingParseResult;
    error(message: string, index?: number | null): void;
    private locationText(index?);
    private skip();
}
}
declare module '@angular/compiler/src/expression_parser/parser' {
export * from '~@angular/compiler/src/expression_parser/parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/metadata_resolver.d.ts
declare module '~@angular/compiler/src/metadata_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Component, Directive, InjectionToken, Type, ɵConsole as Console, ɵReflectorReader } from '@angular/core';
import { StaticSymbol, StaticSymbolCache } from '~@angular/compiler/src/aot/static_symbol';
import * as cpl from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { DirectiveNormalizer } from '~@angular/compiler/src/directive_normalizer';
import { DirectiveResolver } from '~@angular/compiler/src/directive_resolver';
import { NgModuleResolver } from '~@angular/compiler/src/ng_module_resolver';
import { PipeResolver } from '~@angular/compiler/src/pipe_resolver';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
import { SummaryResolver } from '~@angular/compiler/src/summary_resolver';
export type ErrorCollector = (error: any, type?: any) => void;
export const ERROR_COLLECTOR_TOKEN: InjectionToken<{}>;
export class CompileMetadataResolver {
    private _config;
    private _ngModuleResolver;
    private _directiveResolver;
    private _pipeResolver;
    private _summaryResolver;
    private _schemaRegistry;
    private _directiveNormalizer;
    private _console;
    private _staticSymbolCache;
    private _reflector;
    private _errorCollector;
    private _nonNormalizedDirectiveCache;
    private _directiveCache;
    private _summaryCache;
    private _pipeCache;
    private _ngModuleCache;
    private _ngModuleOfTypes;
    constructor(_config: CompilerConfig, _ngModuleResolver: NgModuleResolver, _directiveResolver: DirectiveResolver, _pipeResolver: PipeResolver, _summaryResolver: SummaryResolver<any>, _schemaRegistry: ElementSchemaRegistry, _directiveNormalizer: DirectiveNormalizer, _console: Console, _staticSymbolCache: StaticSymbolCache, _reflector?: ɵReflectorReader, _errorCollector?: ErrorCollector);
    clearCacheFor(type: Type<any>): void;
    clearCache(): void;
    private _createProxyClass(baseType, name);
    private getGeneratedClass(dirType, name);
    private getComponentViewClass(dirType);
    getHostComponentViewClass(dirType: any): StaticSymbol | cpl.ProxyClass;
    getHostComponentType(dirType: any): StaticSymbol | Type<any>;
    private getRendererType(dirType);
    private getComponentFactory(selector, dirType, inputs, outputs);
    private initComponentFactory(factory, ngContentSelectors);
    private _loadSummary(type, kind);
    private _loadDirectiveMetadata(ngModuleType, directiveType, isSync);
    getNonNormalizedDirectiveMetadata(directiveType: any): {
        annotation: Directive;
        metadata: cpl.CompileDirectiveMetadata;
    } | null;
    /**
     * Gets the metadata for the given directive.
     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
     */
    getDirectiveMetadata(directiveType: any): cpl.CompileDirectiveMetadata;
    getDirectiveSummary(dirType: any): cpl.CompileDirectiveSummary;
    isDirective(type: any): boolean;
    isPipe(type: any): boolean;
    getNgModuleSummary(moduleType: any): cpl.CompileNgModuleSummary | null;
    /**
     * Loads the declared directives and pipes of an NgModule.
     */
    loadNgModuleDirectiveAndPipeMetadata(moduleType: any, isSync: boolean, throwIfNotFound?: boolean): Promise<any>;
    getNgModuleMetadata(moduleType: any, throwIfNotFound?: boolean): cpl.CompileNgModuleMetadata | null;
    private _checkSelfImport(moduleType, importedModuleType);
    private _getTypeDescriptor(type);
    private _addTypeToModule(type, moduleType);
    private _getTransitiveNgModuleMetadata(importedModules, exportedModules);
    private _getIdentifierMetadata(type);
    isInjectable(type: any): boolean;
    getInjectableSummary(type: any): cpl.CompileTypeSummary;
    private _getInjectableMetadata(type, dependencies?);
    private _getTypeMetadata(type, dependencies?, throwOnUnknownDeps?);
    private _getFactoryMetadata(factory, dependencies?);
    /**
     * Gets the metadata for the given pipe.
     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
     */
    getPipeMetadata(pipeType: any): cpl.CompilePipeMetadata | null;
    getPipeSummary(pipeType: any): cpl.CompilePipeSummary;
    getOrLoadPipeMetadata(pipeType: any): cpl.CompilePipeMetadata;
    private _loadPipeMetadata(pipeType);
    private _getDependenciesMetadata(typeOrFunc, dependencies, throwOnUnknownDeps?);
    private _getTokenMetadata(token);
    private _getProvidersMetadata(providers, targetEntryComponents, debugInfo?, compileProviders?, type?);
    private _validateProvider(provider);
    private _getEntryComponentsFromProvider(provider, type?);
    private _getEntryComponentMetadata(dirType, throwIfNotFound?);
    getProviderMetadata(provider: cpl.ProviderMeta): cpl.CompileProviderMetadata;
    private _getQueriesMetadata(queries, isViewQuery, directiveType);
    private _queryVarBindings(selector);
    private _getQueryMetadata(q, propertyName, typeOrFunc);
    private _reportError(error, type?, otherType?);
}
export function componentModuleUrl(reflector: ɵReflectorReader, type: Type<any>, cmpMetadata: Component): string;
}
declare module '@angular/compiler/src/metadata_resolver' {
export * from '~@angular/compiler/src/metadata_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/ast.d.ts
declare module '~@angular/compiler/src/ml_parser/ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
export interface Node {
    sourceSpan: ParseSourceSpan;
    visit(visitor: Visitor, context: any): any;
}
export class Text implements Node {
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Expansion implements Node {
    switchValue: string;
    type: string;
    cases: ExpansionCase[];
    sourceSpan: ParseSourceSpan;
    switchValueSourceSpan: ParseSourceSpan;
    constructor(switchValue: string, type: string, cases: ExpansionCase[], sourceSpan: ParseSourceSpan, switchValueSourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class ExpansionCase implements Node {
    value: string;
    expression: Node[];
    sourceSpan: ParseSourceSpan;
    valueSourceSpan: ParseSourceSpan;
    expSourceSpan: ParseSourceSpan;
    constructor(value: string, expression: Node[], sourceSpan: ParseSourceSpan, valueSourceSpan: ParseSourceSpan, expSourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Attribute implements Node {
    name: string;
    value: string;
    sourceSpan: ParseSourceSpan;
    valueSpan: ParseSourceSpan;
    constructor(name: string, value: string, sourceSpan: ParseSourceSpan, valueSpan?: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Element implements Node {
    name: string;
    attrs: Attribute[];
    children: Node[];
    sourceSpan: ParseSourceSpan;
    startSourceSpan: ParseSourceSpan | null;
    endSourceSpan: ParseSourceSpan | null;
    constructor(name: string, attrs: Attribute[], children: Node[], sourceSpan: ParseSourceSpan, startSourceSpan?: ParseSourceSpan | null, endSourceSpan?: ParseSourceSpan | null);
    visit(visitor: Visitor, context: any): any;
}
export class Comment implements Node {
    value: string | null;
    sourceSpan: ParseSourceSpan;
    constructor(value: string | null, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export interface Visitor {
    visit?(node: Node, context: any): any;
    visitElement(element: Element, context: any): any;
    visitAttribute(attribute: Attribute, context: any): any;
    visitText(text: Text, context: any): any;
    visitComment(comment: Comment, context: any): any;
    visitExpansion(expansion: Expansion, context: any): any;
    visitExpansionCase(expansionCase: ExpansionCase, context: any): any;
}
export function visitAll(visitor: Visitor, nodes: Node[], context?: any): any[];
}
declare module '@angular/compiler/src/ml_parser/ast' {
export * from '~@angular/compiler/src/ml_parser/ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/parser.d.ts
declare module '~@angular/compiler/src/ml_parser/parser' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ParseError, ParseSourceSpan } from '~@angular/compiler/src/parse_util';
import * as html from '~@angular/compiler/src/ml_parser/ast';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { TagDefinition } from '~@angular/compiler/src/ml_parser/tags';
export class TreeError extends ParseError {
    elementName: string | null;
    static create(elementName: string | null, span: ParseSourceSpan, msg: string): TreeError;
    constructor(elementName: string | null, span: ParseSourceSpan, msg: string);
}
export class ParseTreeResult {
    rootNodes: html.Node[];
    errors: ParseError[];
    constructor(rootNodes: html.Node[], errors: ParseError[]);
}
export class Parser {
    getTagDefinition: (tagName: string) => TagDefinition;
    constructor(getTagDefinition: (tagName: string) => TagDefinition);
    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;
}
}
declare module '@angular/compiler/src/ml_parser/parser' {
export * from '~@angular/compiler/src/ml_parser/parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/html_parser.d.ts
declare module '~@angular/compiler/src/ml_parser/html_parser' {
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseTreeResult, Parser } from '~@angular/compiler/src/ml_parser/parser';
export { ParseTreeResult, TreeError } from '~@angular/compiler/src/ml_parser/parser';
export class HtmlParser extends Parser {
    constructor();
    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;
}
}
declare module '@angular/compiler/src/ml_parser/html_parser' {
export * from '~@angular/compiler/src/ml_parser/html_parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/html_tags.d.ts
declare module '~@angular/compiler/src/ml_parser/html_tags' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { TagContentType, TagDefinition } from '~@angular/compiler/src/ml_parser/tags';
export class HtmlTagDefinition implements TagDefinition {
    private closedByChildren;
    closedByParent: boolean;
    requiredParents: {
        [key: string]: boolean;
    };
    parentToAdd: string;
    implicitNamespacePrefix: string | null;
    contentType: TagContentType;
    isVoid: boolean;
    ignoreFirstLf: boolean;
    canSelfClose: boolean;
    constructor({closedByChildren, requiredParents, implicitNamespacePrefix, contentType, closedByParent, isVoid, ignoreFirstLf}?: {
        closedByChildren?: string[];
        closedByParent?: boolean;
        requiredParents?: string[];
        implicitNamespacePrefix?: string;
        contentType?: TagContentType;
        isVoid?: boolean;
        ignoreFirstLf?: boolean;
    });
    requireExtraParent(currentParent: string): boolean;
    isClosedByChild(name: string): boolean;
}
export function getHtmlTagDefinition(tagName: string): HtmlTagDefinition;
}
declare module '@angular/compiler/src/ml_parser/html_tags' {
export * from '~@angular/compiler/src/ml_parser/html_tags';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/tags.d.ts
declare module '~@angular/compiler/src/ml_parser/tags' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export enum TagContentType {
    RAW_TEXT = 0,
    ESCAPABLE_RAW_TEXT = 1,
    PARSABLE_DATA = 2,
}
export interface TagDefinition {
    closedByParent: boolean;
    requiredParents: {
        [key: string]: boolean;
    };
    parentToAdd: string;
    implicitNamespacePrefix: string | null;
    contentType: TagContentType;
    isVoid: boolean;
    ignoreFirstLf: boolean;
    canSelfClose: boolean;
    requireExtraParent(currentParent: string): boolean;
    isClosedByChild(name: string): boolean;
}
export function splitNsName(elementName: string): [string | null, string];
export function isNgContainer(tagName: string): boolean;
export function isNgContent(tagName: string): boolean;
export function isNgTemplate(tagName: string): boolean;
export function getNsPrefix(fullName: string): string;
export function getNsPrefix(fullName: null): null;
export function mergeNsAndName(prefix: string, localName: string): string;
export const NAMED_ENTITIES: {
    [k: string]: string;
};
}
declare module '@angular/compiler/src/ml_parser/tags' {
export * from '~@angular/compiler/src/ml_parser/tags';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ng_module_compiler.d.ts
declare module '~@angular/compiler/src/ng_module_compiler' {
import { CompileNgModuleMetadata, CompileProviderMetadata } from '~@angular/compiler/src/compile_metadata';
import * as o from '~@angular/compiler/src/output/output_ast';
/**
 * This is currently not read, but will probably be used in the future.
 * We keep it as we already pass it through all the rigth places...
 */
export class ComponentFactoryDependency {
    compType: any;
    constructor(compType: any);
}
export class NgModuleCompileResult {
    statements: o.Statement[];
    ngModuleFactoryVar: string;
    dependencies: ComponentFactoryDependency[];
    constructor(statements: o.Statement[], ngModuleFactoryVar: string, dependencies: ComponentFactoryDependency[]);
}
export class NgModuleCompiler {
    compile(ngModuleMeta: CompileNgModuleMetadata, extraProviders: CompileProviderMetadata[]): NgModuleCompileResult;
}
}
declare module '@angular/compiler/src/ng_module_compiler' {
export * from '~@angular/compiler/src/ng_module_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/path_util.d.ts
declare module '~@angular/compiler/src/output/path_util' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { StaticSymbol } from '~@angular/compiler/src/aot/static_symbol';
/**
 * Interface that defines how import statements should be generated.
 */
export abstract class ImportResolver {
    /**
     * Converts a file path to a module name that can be used as an `import.
     * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.
     */
    abstract fileNameToModuleName(importedFilePath: string, containingFilePath: string): string | null;
    /**
     * Converts the given StaticSymbol into another StaticSymbol that should be used
     * to generate the import from.
     */
    abstract getImportAs(symbol: StaticSymbol): StaticSymbol | null;
    /**
     * Determine the arity of a type.
     */
    abstract getTypeArity(symbol: StaticSymbol): number | null;
}
}
declare module '@angular/compiler/src/output/path_util' {
export * from '~@angular/compiler/src/output/path_util';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/output_ast.d.ts
declare module '~@angular/compiler/src/output/output_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileIdentifierMetadata } from '~@angular/compiler/src/compile_metadata';
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
export enum TypeModifier {
    Const = 0,
}
export abstract class Type {
    modifiers: TypeModifier[] | null;
    constructor(modifiers?: TypeModifier[] | null);
    abstract visitType(visitor: TypeVisitor, context: any): any;
    hasModifier(modifier: TypeModifier): boolean;
}
export enum BuiltinTypeName {
    Dynamic = 0,
    Bool = 1,
    String = 2,
    Int = 3,
    Number = 4,
    Function = 5,
    Inferred = 6,
}
export class BuiltinType extends Type {
    name: BuiltinTypeName;
    constructor(name: BuiltinTypeName, modifiers?: TypeModifier[] | null);
    visitType(visitor: TypeVisitor, context: any): any;
}
export class ExpressionType extends Type {
    value: Expression;
    constructor(value: Expression, modifiers?: TypeModifier[] | null);
    visitType(visitor: TypeVisitor, context: any): any;
}
export class ArrayType extends Type {
    of: Type;
    constructor(of: Type, modifiers?: TypeModifier[] | null);
    visitType(visitor: TypeVisitor, context: any): any;
}
export class MapType extends Type {
    valueType: Type | null;
    constructor(valueType: Type | null | undefined, modifiers?: TypeModifier[] | null);
    visitType(visitor: TypeVisitor, context: any): any;
}
export const DYNAMIC_TYPE: BuiltinType;
export const INFERRED_TYPE: BuiltinType;
export const BOOL_TYPE: BuiltinType;
export const INT_TYPE: BuiltinType;
export const NUMBER_TYPE: BuiltinType;
export const STRING_TYPE: BuiltinType;
export const FUNCTION_TYPE: BuiltinType;
export interface TypeVisitor {
    visitBuiltintType(type: BuiltinType, context: any): any;
    visitExpressionType(type: ExpressionType, context: any): any;
    visitArrayType(type: ArrayType, context: any): any;
    visitMapType(type: MapType, context: any): any;
}
export enum BinaryOperator {
    Equals = 0,
    NotEquals = 1,
    Identical = 2,
    NotIdentical = 3,
    Minus = 4,
    Plus = 5,
    Divide = 6,
    Multiply = 7,
    Modulo = 8,
    And = 9,
    Or = 10,
    Lower = 11,
    LowerEquals = 12,
    Bigger = 13,
    BiggerEquals = 14,
}
export abstract class Expression {
    type: Type | null;
    sourceSpan: ParseSourceSpan | null;
    constructor(type: Type | null | undefined, sourceSpan?: ParseSourceSpan | null);
    abstract visitExpression(visitor: ExpressionVisitor, context: any): any;
    prop(name: string, sourceSpan?: ParseSourceSpan | null): ReadPropExpr;
    key(index: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null): ReadKeyExpr;
    callMethod(name: string | BuiltinMethod, params: Expression[], sourceSpan?: ParseSourceSpan | null): InvokeMethodExpr;
    callFn(params: Expression[], sourceSpan?: ParseSourceSpan | null): InvokeFunctionExpr;
    instantiate(params: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null): InstantiateExpr;
    conditional(trueCase: Expression, falseCase?: Expression | null, sourceSpan?: ParseSourceSpan | null): ConditionalExpr;
    equals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    identical(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    minus(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    plus(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    divide(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    multiply(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    modulo(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    and(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    or(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    lower(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    bigger(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr;
    isBlank(sourceSpan?: ParseSourceSpan | null): Expression;
    cast(type: Type, sourceSpan?: ParseSourceSpan | null): Expression;
    toStmt(): Statement;
}
export enum BuiltinVar {
    This = 0,
    Super = 1,
    CatchError = 2,
    CatchStack = 3,
}
export class ReadVarExpr extends Expression {
    name: string | null;
    builtin: BuiltinVar | null;
    constructor(name: string | BuiltinVar, type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    set(value: Expression): WriteVarExpr;
}
export class WriteVarExpr extends Expression {
    name: string;
    value: Expression;
    constructor(name: string, value: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    toDeclStmt(type?: Type | null, modifiers?: StmtModifier[] | null): DeclareVarStmt;
}
export class WriteKeyExpr extends Expression {
    receiver: Expression;
    index: Expression;
    value: Expression;
    constructor(receiver: Expression, index: Expression, value: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class WritePropExpr extends Expression {
    receiver: Expression;
    name: string;
    value: Expression;
    constructor(receiver: Expression, name: string, value: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export enum BuiltinMethod {
    ConcatArray = 0,
    SubscribeObservable = 1,
    Bind = 2,
}
export class InvokeMethodExpr extends Expression {
    receiver: Expression;
    args: Expression[];
    name: string | null;
    builtin: BuiltinMethod | null;
    constructor(receiver: Expression, method: string | BuiltinMethod, args: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class InvokeFunctionExpr extends Expression {
    fn: Expression;
    args: Expression[];
    constructor(fn: Expression, args: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class InstantiateExpr extends Expression {
    classExpr: Expression;
    args: Expression[];
    constructor(classExpr: Expression, args: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class LiteralExpr extends Expression {
    value: any;
    constructor(value: any, type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class ExternalExpr extends Expression {
    value: CompileIdentifierMetadata;
    typeParams: Type[] | null;
    constructor(value: CompileIdentifierMetadata, type?: Type | null, typeParams?: Type[] | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class ConditionalExpr extends Expression {
    condition: Expression;
    falseCase: Expression | null;
    trueCase: Expression;
    constructor(condition: Expression, trueCase: Expression, falseCase?: Expression | null, type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class NotExpr extends Expression {
    condition: Expression;
    constructor(condition: Expression, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class CastExpr extends Expression {
    value: Expression;
    constructor(value: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class FnParam {
    name: string;
    type: Type | null;
    constructor(name: string, type?: Type | null);
}
export class FunctionExpr extends Expression {
    params: FnParam[];
    statements: Statement[];
    constructor(params: FnParam[], statements: Statement[], type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    toDeclStmt(name: string, modifiers?: StmtModifier[] | null): DeclareFunctionStmt;
}
export class BinaryOperatorExpr extends Expression {
    operator: BinaryOperator;
    rhs: Expression;
    lhs: Expression;
    constructor(operator: BinaryOperator, lhs: Expression, rhs: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class ReadPropExpr extends Expression {
    receiver: Expression;
    name: string;
    constructor(receiver: Expression, name: string, type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    set(value: Expression): WritePropExpr;
}
export class ReadKeyExpr extends Expression {
    receiver: Expression;
    index: Expression;
    constructor(receiver: Expression, index: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    set(value: Expression): WriteKeyExpr;
}
export class LiteralArrayExpr extends Expression {
    entries: Expression[];
    constructor(entries: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class LiteralMapEntry {
    key: string;
    value: Expression;
    quoted: boolean;
    constructor(key: string, value: Expression, quoted?: boolean);
}
export class LiteralMapExpr extends Expression {
    entries: LiteralMapEntry[];
    valueType: Type | null;
    constructor(entries: LiteralMapEntry[], type?: MapType | null, sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class CommaExpr extends Expression {
    parts: Expression[];
    constructor(parts: Expression[], sourceSpan?: ParseSourceSpan | null);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export interface ExpressionVisitor {
    visitReadVarExpr(ast: ReadVarExpr, context: any): any;
    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;
    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;
    visitWritePropExpr(expr: WritePropExpr, context: any): any;
    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;
    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;
    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;
    visitLiteralExpr(ast: LiteralExpr, context: any): any;
    visitExternalExpr(ast: ExternalExpr, context: any): any;
    visitConditionalExpr(ast: ConditionalExpr, context: any): any;
    visitNotExpr(ast: NotExpr, context: any): any;
    visitCastExpr(ast: CastExpr, context: any): any;
    visitFunctionExpr(ast: FunctionExpr, context: any): any;
    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;
    visitReadPropExpr(ast: ReadPropExpr, context: any): any;
    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;
    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;
    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;
    visitCommaExpr(ast: CommaExpr, context: any): any;
}
export const THIS_EXPR: ReadVarExpr;
export const SUPER_EXPR: ReadVarExpr;
export const CATCH_ERROR_VAR: ReadVarExpr;
export const CATCH_STACK_VAR: ReadVarExpr;
export const NULL_EXPR: LiteralExpr;
export const TYPED_NULL_EXPR: LiteralExpr;
export enum StmtModifier {
    Final = 0,
    Private = 1,
}
export abstract class Statement {
    modifiers: StmtModifier[];
    sourceSpan: ParseSourceSpan | null;
    constructor(modifiers?: StmtModifier[] | null, sourceSpan?: ParseSourceSpan | null);
    abstract visitStatement(visitor: StatementVisitor, context: any): any;
    hasModifier(modifier: StmtModifier): boolean;
}
export class DeclareVarStmt extends Statement {
    name: string;
    value: Expression;
    type: Type | null;
    constructor(name: string, value: Expression, type?: Type | null, modifiers?: StmtModifier[] | null, sourceSpan?: ParseSourceSpan | null);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class DeclareFunctionStmt extends Statement {
    name: string;
    params: FnParam[];
    statements: Statement[];
    type: Type | null;
    constructor(name: string, params: FnParam[], statements: Statement[], type?: Type | null, modifiers?: StmtModifier[] | null, sourceSpan?: ParseSourceSpan | null);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class ExpressionStatement extends Statement {
    expr: Expression;
    constructor(expr: Expression, sourceSpan?: ParseSourceSpan | null);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class ReturnStatement extends Statement {
    value: Expression;
    constructor(value: Expression, sourceSpan?: ParseSourceSpan | null);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class AbstractClassPart {
    modifiers: StmtModifier[] | null;
    type: Type | null;
    constructor(type: Type | null | undefined, modifiers: StmtModifier[] | null);
    hasModifier(modifier: StmtModifier): boolean;
}
export class ClassField extends AbstractClassPart {
    name: string;
    constructor(name: string, type?: Type | null, modifiers?: StmtModifier[] | null);
}
export class ClassMethod extends AbstractClassPart {
    name: string | null;
    params: FnParam[];
    body: Statement[];
    constructor(name: string | null, params: FnParam[], body: Statement[], type?: Type | null, modifiers?: StmtModifier[] | null);
}
export class ClassGetter extends AbstractClassPart {
    name: string;
    body: Statement[];
    constructor(name: string, body: Statement[], type?: Type | null, modifiers?: StmtModifier[] | null);
}
export class ClassStmt extends Statement {
    name: string;
    parent: Expression | null;
    fields: ClassField[];
    getters: ClassGetter[];
    constructorMethod: ClassMethod;
    methods: ClassMethod[];
    constructor(name: string, parent: Expression | null, fields: ClassField[], getters: ClassGetter[], constructorMethod: ClassMethod, methods: ClassMethod[], modifiers?: StmtModifier[] | null, sourceSpan?: ParseSourceSpan | null);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class IfStmt extends Statement {
    condition: Expression;
    trueCase: Statement[];
    falseCase: Statement[];
    constructor(condition: Expression, trueCase: Statement[], falseCase?: Statement[], sourceSpan?: ParseSourceSpan | null);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class CommentStmt extends Statement {
    comment: string;
    constructor(comment: string, sourceSpan?: ParseSourceSpan | null);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class TryCatchStmt extends Statement {
    bodyStmts: Statement[];
    catchStmts: Statement[];
    constructor(bodyStmts: Statement[], catchStmts: Statement[], sourceSpan?: ParseSourceSpan | null);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class ThrowStmt extends Statement {
    error: Expression;
    constructor(error: Expression, sourceSpan?: ParseSourceSpan | null);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export interface StatementVisitor {
    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;
    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;
    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;
    visitReturnStmt(stmt: ReturnStatement, context: any): any;
    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;
    visitIfStmt(stmt: IfStmt, context: any): any;
    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;
    visitThrowStmt(stmt: ThrowStmt, context: any): any;
    visitCommentStmt(stmt: CommentStmt, context: any): any;
}
export class AstTransformer implements StatementVisitor, ExpressionVisitor {
    transformExpr(expr: Expression, context: any): Expression;
    transformStmt(stmt: Statement, context: any): Statement;
    visitReadVarExpr(ast: ReadVarExpr, context: any): any;
    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;
    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;
    visitWritePropExpr(expr: WritePropExpr, context: any): any;
    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;
    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;
    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;
    visitLiteralExpr(ast: LiteralExpr, context: any): any;
    visitExternalExpr(ast: ExternalExpr, context: any): any;
    visitConditionalExpr(ast: ConditionalExpr, context: any): any;
    visitNotExpr(ast: NotExpr, context: any): any;
    visitCastExpr(ast: CastExpr, context: any): any;
    visitFunctionExpr(ast: FunctionExpr, context: any): any;
    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;
    visitReadPropExpr(ast: ReadPropExpr, context: any): any;
    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;
    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;
    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;
    visitCommaExpr(ast: CommaExpr, context: any): any;
    visitAllExpressions(exprs: Expression[], context: any): Expression[];
    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;
    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;
    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;
    visitReturnStmt(stmt: ReturnStatement, context: any): any;
    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;
    visitIfStmt(stmt: IfStmt, context: any): any;
    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;
    visitThrowStmt(stmt: ThrowStmt, context: any): any;
    visitCommentStmt(stmt: CommentStmt, context: any): any;
    visitAllStatements(stmts: Statement[], context: any): Statement[];
}
export class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {
    visitReadVarExpr(ast: ReadVarExpr, context: any): any;
    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;
    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;
    visitWritePropExpr(expr: WritePropExpr, context: any): any;
    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;
    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;
    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;
    visitLiteralExpr(ast: LiteralExpr, context: any): any;
    visitExternalExpr(ast: ExternalExpr, context: any): any;
    visitConditionalExpr(ast: ConditionalExpr, context: any): any;
    visitNotExpr(ast: NotExpr, context: any): any;
    visitCastExpr(ast: CastExpr, context: any): any;
    visitFunctionExpr(ast: FunctionExpr, context: any): any;
    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;
    visitReadPropExpr(ast: ReadPropExpr, context: any): any;
    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;
    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;
    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;
    visitCommaExpr(ast: CommaExpr, context: any): any;
    visitAllExpressions(exprs: Expression[], context: any): void;
    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;
    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;
    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;
    visitReturnStmt(stmt: ReturnStatement, context: any): any;
    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;
    visitIfStmt(stmt: IfStmt, context: any): any;
    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;
    visitThrowStmt(stmt: ThrowStmt, context: any): any;
    visitCommentStmt(stmt: CommentStmt, context: any): any;
    visitAllStatements(stmts: Statement[], context: any): void;
}
export function findReadVarNames(stmts: Statement[]): Set<string>;
export function applySourceSpanToStatementIfNeeded(stmt: Statement, sourceSpan: ParseSourceSpan | null): Statement;
export function applySourceSpanToExpressionIfNeeded(expr: Expression, sourceSpan: ParseSourceSpan | null): Expression;
export function variable(name: string, type?: Type | null, sourceSpan?: ParseSourceSpan | null): ReadVarExpr;
export function importExpr(id: CompileIdentifierMetadata, typeParams?: Type[] | null, sourceSpan?: ParseSourceSpan | null): ExternalExpr;
export function importType(id: CompileIdentifierMetadata, typeParams?: Type[] | null, typeModifiers?: TypeModifier[] | null): ExpressionType | null;
export function expressionType(expr: Expression, typeModifiers?: TypeModifier[] | null): ExpressionType | null;
export function literalArr(values: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null): LiteralArrayExpr;
export function literalMap(values: [string, Expression][], type?: MapType | null, quoted?: boolean): LiteralMapExpr;
export function not(expr: Expression, sourceSpan?: ParseSourceSpan | null): NotExpr;
export function fn(params: FnParam[], body: Statement[], type?: Type | null, sourceSpan?: ParseSourceSpan | null): FunctionExpr;
export function literal(value: any, type?: Type | null, sourceSpan?: ParseSourceSpan | null): LiteralExpr;
}
declare module '@angular/compiler/src/output/output_ast' {
export * from '~@angular/compiler/src/output/output_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/ts_emitter.d.ts
declare module '~@angular/compiler/src/output/ts_emitter' {
import { OutputEmitter } from '~@angular/compiler/src/output/abstract_emitter';
import * as o from '~@angular/compiler/src/output/output_ast';
import { ImportResolver } from '~@angular/compiler/src/output/path_util';
export function debugOutputAstAsTypeScript(ast: o.Statement | o.Expression | o.Type | any[]): string;
export class TypeScriptEmitter implements OutputEmitter {
    private _importResolver;
    constructor(_importResolver: ImportResolver);
    emitStatements(srcFilePath: string, genFilePath: string, stmts: o.Statement[], exportedVars: string[], preamble?: string): string;
}
}
declare module '@angular/compiler/src/output/ts_emitter' {
export * from '~@angular/compiler/src/output/ts_emitter';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/parse_util.d.ts
declare module '~@angular/compiler/src/parse_util' {
import { CompileIdentifierMetadata } from '~@angular/compiler/src/compile_metadata';
export class ParseLocation {
    file: ParseSourceFile;
    offset: number;
    line: number;
    col: number;
    constructor(file: ParseSourceFile, offset: number, line: number, col: number);
    toString(): string;
    moveBy(delta: number): ParseLocation;
    getContext(maxChars: number, maxLines: number): {
        before: string;
        after: string;
    } | null;
}
export class ParseSourceFile {
    content: string;
    url: string;
    constructor(content: string, url: string);
}
export class ParseSourceSpan {
    start: ParseLocation;
    end: ParseLocation;
    details: string | null;
    constructor(start: ParseLocation, end: ParseLocation, details?: string | null);
    toString(): string;
}
export enum ParseErrorLevel {
    WARNING = 0,
    ERROR = 1,
}
export class ParseError {
    span: ParseSourceSpan;
    msg: string;
    level: ParseErrorLevel;
    constructor(span: ParseSourceSpan, msg: string, level?: ParseErrorLevel);
    toString(): string;
}
export function typeSourceSpan(kind: string, type: CompileIdentifierMetadata): ParseSourceSpan;
}
declare module '@angular/compiler/src/parse_util' {
export * from '~@angular/compiler/src/parse_util';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/schema/dom_element_schema_registry.d.ts
declare module '~@angular/compiler/src/schema/dom_element_schema_registry' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SchemaMetadata, SecurityContext } from '@angular/core';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
export class DomElementSchemaRegistry extends ElementSchemaRegistry {
    private _schema;
    constructor();
    hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;
    hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;
    /**
     * securityContext returns the security context for the given property on the given DOM tag.
     *
     * Tag and property name are statically known and cannot change at runtime, i.e. it is not
     * possible to bind a value into a changing attribute or tag name.
     *
     * The filtering is white list based. All attributes in the schema above are assumed to have the
     * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known
     * attack vectors are assigned their appropriate context.
     */
    securityContext(tagName: string, propName: string, isAttribute: boolean): SecurityContext;
    getMappedPropName(propName: string): string;
    getDefaultComponentElementName(): string;
    validateProperty(name: string): {
        error: boolean;
        msg?: string;
    };
    validateAttribute(name: string): {
        error: boolean;
        msg?: string;
    };
    allKnownElementNames(): string[];
    normalizeAnimationStyleProperty(propName: string): string;
    normalizeAnimationStyleValue(camelCaseProp: string, userProvidedProp: string, val: string | number): {
        error: string;
        value: string;
    };
}
}
declare module '@angular/compiler/src/schema/dom_element_schema_registry' {
export * from '~@angular/compiler/src/schema/dom_element_schema_registry';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/selector.d.ts
declare module '~@angular/compiler/src/selector' {
/**
 * A css selector contains an element name,
 * css classes and attribute/value pairs with the purpose
 * of selecting subsets out of them.
 */
export class CssSelector {
    element: string | null;
    classNames: string[];
    attrs: string[];
    notSelectors: CssSelector[];
    static parse(selector: string): CssSelector[];
    isElementSelector(): boolean;
    hasElementSelector(): boolean;
    setElement(element?: string | null): void;
    /** Gets a template string for an element that matches the selector. */
    getMatchingElementTemplate(): string;
    addAttribute(name: string, value?: string): void;
    addClassName(name: string): void;
    toString(): string;
}
/**
 * Reads a list of CssSelectors and allows to calculate which ones
 * are contained in a given CssSelector.
 */
export class SelectorMatcher {
    static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher;
    private _elementMap;
    private _elementPartialMap;
    private _classMap;
    private _classPartialMap;
    private _attrValueMap;
    private _attrValuePartialMap;
    private _listContexts;
    addSelectables(cssSelectors: CssSelector[], callbackCtxt?: any): void;
    /**
     * Add an object that can be found later on by calling `match`.
     * @param cssSelector A css selector
     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
     */
    private _addSelectable(cssSelector, callbackCtxt, listContext);
    private _addTerminal(map, name, selectable);
    private _addPartial(map, name);
    /**
     * Find the objects that have been added via `addSelectable`
     * whose css selector is contained in the given css selector.
     * @param cssSelector A css selector
     * @param matchedCallback This callback will be called with the object handed into `addSelectable`
     * @return boolean true if a match was found
    */
    match(cssSelector: CssSelector, matchedCallback: ((c: CssSelector, a: any) => void) | null): boolean;
}
export class SelectorListContext {
    selectors: CssSelector[];
    alreadyMatched: boolean;
    constructor(selectors: CssSelector[]);
}
export class SelectorContext {
    selector: CssSelector;
    cbContext: any;
    listContext: SelectorListContext;
    notSelectors: CssSelector[];
    constructor(selector: CssSelector, cbContext: any, listContext: SelectorListContext);
    finalize(cssSelector: CssSelector, callback: ((c: CssSelector, a: any) => void) | null): boolean;
}
}
declare module '@angular/compiler/src/selector' {
export * from '~@angular/compiler/src/selector';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/style_compiler.d.ts
declare module '~@angular/compiler/src/style_compiler' {
import { CompileDirectiveMetadata, CompileIdentifierMetadata, CompileStylesheetMetadata } from '~@angular/compiler/src/compile_metadata';
import * as o from '~@angular/compiler/src/output/output_ast';
import { UrlResolver } from '~@angular/compiler/src/url_resolver';
export class StylesCompileDependency {
    name: string;
    moduleUrl: string;
    isShimmed: boolean;
    valuePlaceholder: CompileIdentifierMetadata;
    constructor(name: string, moduleUrl: string, isShimmed: boolean, valuePlaceholder: CompileIdentifierMetadata);
}
export class StylesCompileResult {
    componentStylesheet: CompiledStylesheet;
    externalStylesheets: CompiledStylesheet[];
    constructor(componentStylesheet: CompiledStylesheet, externalStylesheets: CompiledStylesheet[]);
}
export class CompiledStylesheet {
    statements: o.Statement[];
    stylesVar: string;
    dependencies: StylesCompileDependency[];
    isShimmed: boolean;
    meta: CompileStylesheetMetadata;
    constructor(statements: o.Statement[], stylesVar: string, dependencies: StylesCompileDependency[], isShimmed: boolean, meta: CompileStylesheetMetadata);
}
export class StyleCompiler {
    private _urlResolver;
    private _shadowCss;
    constructor(_urlResolver: UrlResolver);
    compileComponent(comp: CompileDirectiveMetadata): StylesCompileResult;
    private _compileStyles(comp, stylesheet, isComponentStylesheet);
    private _shimIfNeeded(style, shim);
}
}
declare module '@angular/compiler/src/style_compiler' {
export * from '~@angular/compiler/src/style_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/view_compiler/view_compiler.d.ts
declare module '~@angular/compiler/src/view_compiler/view_compiler' {
import { CompileDirectiveMetadata, CompilePipeSummary } from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import * as o from '~@angular/compiler/src/output/output_ast';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
import { TemplateAst } from '~@angular/compiler/src/template_parser/template_ast';
export class ViewCompileResult {
    statements: o.Statement[];
    viewClassVar: string;
    rendererTypeVar: string;
    constructor(statements: o.Statement[], viewClassVar: string, rendererTypeVar: string);
}
export class ViewCompiler {
    private _genConfigNext;
    private _schemaRegistry;
    constructor(_genConfigNext: CompilerConfig, _schemaRegistry: ElementSchemaRegistry);
    compileComponent(component: CompileDirectiveMetadata, template: TemplateAst[], styles: o.Expression, usedPipes: CompilePipeSummary[]): ViewCompileResult;
}
}
declare module '@angular/compiler/src/view_compiler/view_compiler' {
export * from '~@angular/compiler/src/view_compiler/view_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/util.d.ts
declare module '~@angular/compiler/src/util' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export const MODULE_SUFFIX = "";
export function camelCaseToDashCase(input: string): string;
export function dashCaseToCamelCase(input: string): string;
export function splitAtColon(input: string, defaultValues: string[]): string[];
export function splitAtPeriod(input: string, defaultValues: string[]): string[];
export function visitValue(value: any, visitor: ValueVisitor, context: any): any;
export function isDefined(val: any): boolean;
export function noUndefined<T>(val: T | undefined): T;
export interface ValueVisitor {
    visitArray(arr: any[], context: any): any;
    visitStringMap(map: {
        [key: string]: any;
    }, context: any): any;
    visitPrimitive(value: any, context: any): any;
    visitOther(value: any, context: any): any;
}
export class ValueTransformer implements ValueVisitor {
    visitArray(arr: any[], context: any): any;
    visitStringMap(map: {
        [key: string]: any;
    }, context: any): any;
    visitPrimitive(value: any, context: any): any;
    visitOther(value: any, context: any): any;
}
export class SyncAsyncResult<T> {
    syncResult: T | null;
    asyncResult: Promise<T> | null;
    constructor(syncResult: T | null, asyncResult?: Promise<T> | null);
}
export function syntaxError(msg: string): Error;
export function isSyntaxError(error: Error): boolean;
export function escapeRegExp(s: string): string;
export function utf8Encode(str: string): string;
}
declare module '@angular/compiler/src/util' {
export * from '~@angular/compiler/src/util';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/compiler.d.ts
declare module '~@angular/compiler/src/compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all APIs of the compiler package.
 *
 * <div class="callout is-critical">
 *   <header>Unstable APIs</header>
 *   <p>
 *     All compiler apis are currently considered experimental and private!
 *   </p>
 *   <p>
 *     We expect the APIs in this package to keep on changing. Do not rely on them.
 *   </p>
 * </div>
 */
export { VERSION } from '~@angular/compiler/src/version';
export * from '~@angular/compiler/src/template_parser/template_ast';
export { TEMPLATE_TRANSFORMS } from '~@angular/compiler/src/template_parser/template_parser';
export { CompilerConfig } from '~@angular/compiler/src/config';
export * from '~@angular/compiler/src/compile_metadata';
export * from '~@angular/compiler/src/aot/compiler_factory';
export * from '~@angular/compiler/src/aot/compiler';
export * from '~@angular/compiler/src/aot/generated_file';
export * from '~@angular/compiler/src/aot/compiler_options';
export * from '~@angular/compiler/src/aot/compiler_host';
export * from '~@angular/compiler/src/aot/static_reflector';
export * from '~@angular/compiler/src/aot/static_reflection_capabilities';
export * from '~@angular/compiler/src/aot/static_symbol';
export * from '~@angular/compiler/src/aot/static_symbol_resolver';
export * from '~@angular/compiler/src/aot/summary_resolver';
export * from '~@angular/compiler/src/summary_resolver';
export { JitCompiler } from '~@angular/compiler/src/jit/compiler';
export * from '~@angular/compiler/src/jit/compiler_factory';
export * from '~@angular/compiler/src/url_resolver';
export * from '~@angular/compiler/src/resource_loader';
export { DirectiveResolver } from '~@angular/compiler/src/directive_resolver';
export { PipeResolver } from '~@angular/compiler/src/pipe_resolver';
export { NgModuleResolver } from '~@angular/compiler/src/ng_module_resolver';
export { DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
export * from '~@angular/compiler/src/schema/element_schema_registry';
export * from '~@angular/compiler/src/i18n/index';
export * from '~@angular/compiler/src/directive_normalizer';
export * from '~@angular/compiler/src/expression_parser/ast';
export * from '~@angular/compiler/src/expression_parser/lexer';
export * from '~@angular/compiler/src/expression_parser/parser';
export * from '~@angular/compiler/src/metadata_resolver';
export * from '~@angular/compiler/src/ml_parser/ast';
export * from '~@angular/compiler/src/ml_parser/html_parser';
export * from '~@angular/compiler/src/ml_parser/html_tags';
export * from '~@angular/compiler/src/ml_parser/interpolation_config';
export * from '~@angular/compiler/src/ml_parser/tags';
export { NgModuleCompiler } from '~@angular/compiler/src/ng_module_compiler';
export * from '~@angular/compiler/src/output/path_util';
export * from '~@angular/compiler/src/output/ts_emitter';
export * from '~@angular/compiler/src/parse_util';
export * from '~@angular/compiler/src/schema/dom_element_schema_registry';
export * from '~@angular/compiler/src/selector';
export * from '~@angular/compiler/src/style_compiler';
export * from '~@angular/compiler/src/template_parser/template_parser';
export { ViewCompiler } from '~@angular/compiler/src/view_compiler/view_compiler';
export { isSyntaxError, syntaxError } from '~@angular/compiler/src/util';
}
declare module '@angular/compiler/src/compiler' {
export * from '~@angular/compiler/src/compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/compiler.d.ts
declare module '~@angular/compiler/compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the compiler package.
 */
export * from '~@angular/compiler/src/compiler';
}
declare module '@angular/compiler/compiler' {
export * from '~@angular/compiler/compiler';
}
declare module '@angular/compiler' {
export * from '~@angular/compiler/compiler';
}
