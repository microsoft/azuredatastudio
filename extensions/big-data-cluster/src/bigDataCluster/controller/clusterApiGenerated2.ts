/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// Note: this file will hopefully be merged with apiGenerated.ts at a later date, once the server-side code
// is available from a single source of truth. Until then, keeping as separate files

/* tslint:disable: no-unexternalized-strings */
/* tslint:disable: semicolon */
/* tslint:disable: triple-equals */
/* tslint:disable: no-redundant-jsdoc */

import localVarRequest = require('request');
import http = require('http');

let defaultBasePath = 'https://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
	"string",
	"boolean",
	"double",
	"integer",
	"long",
	"float",
	"number",
	"any"
];

class ObjectSerializer {

	public static findCorrectType(data: any, expectedType: string) {
		if (data == undefined) {
			return expectedType;
		} else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
			return expectedType;
		} else if (expectedType === "Date") {
			return expectedType;
		} else {
			if (enumsMap[expectedType]) {
				return expectedType;
			}

			if (!typeMap[expectedType]) {
				return expectedType; // w/e we don't know the type
			}

			// Check the discriminator
			let discriminatorProperty = typeMap[expectedType].discriminator;
			if (discriminatorProperty == null) {
				return expectedType; // the type does not have a discriminator. use it.
			} else {
				if (data[discriminatorProperty]) {
					return data[discriminatorProperty]; // use the type given in the discriminator
				} else {
					return expectedType; // discriminator was not present (or an empty string)
				}
			}
		}
	}

	public static serialize(data: any, type: string) {
		if (data == undefined) {
			return data;
		} else if (primitives.indexOf(type.toLowerCase()) !== -1) {
			return data;
		} else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
			let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
			subType = subType.substring(0, subType.length - 1); // Type> => Type
			let transformedData: any[] = [];
			for (let index in data) {
				let date = data[index];
				transformedData.push(ObjectSerializer.serialize(date, subType));
			}
			return transformedData;
		} else if (type === "Date") {
			return data.toString();
		} else {
			if (enumsMap[type]) {
				return data;
			}
			if (!typeMap[type]) { // in case we dont know the type
				return data;
			}

			// get the map for the correct type.
			let attributeTypes = typeMap[type].getAttributeTypeMap();
			let instance: { [index: string]: any } = {};
			for (let index in attributeTypes) {
				let attributeType = attributeTypes[index];
				instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
			}
			return instance;
		}
	}

	public static deserialize(data: any, type: string) {
		// polymorphism may change the actual type.
		type = ObjectSerializer.findCorrectType(data, type);
		if (data == undefined) {
			return data;
		} else if (primitives.indexOf(type.toLowerCase()) !== -1) {
			return data;
		} else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
			let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
			subType = subType.substring(0, subType.length - 1); // Type> => Type
			let transformedData: any[] = [];
			for (let index in data) {
				let date = data[index];
				transformedData.push(ObjectSerializer.deserialize(date, subType));
			}
			return transformedData;
		} else if (type === "Date") {
			return new Date(data);
		} else {
			if (enumsMap[type]) {// is Enum
				return data;
			}

			if (!typeMap[type]) { // dont know the type
				return data;
			}
			let instance = new typeMap[type]();
			let attributeTypes = typeMap[type].getAttributeTypeMap();
			for (let index in attributeTypes) {
				let attributeType = attributeTypes[index];
				instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
			}
			return instance;
		}
	}
}

export class AppModel {
	'name'?: string;
	'internalName'?: string;
	'version'?: string;
	'inputParamDefs'?: Array<AppModelParameterDefinition>;
	'outputParamDefs'?: Array<AppModelParameterDefinition>;
	'state'?: string;
	'links'?: { [key: string]: string; };

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
		{
			"name": "name",
			"baseName": "name",
			"type": "string"
		},
		{
			"name": "internalName",
			"baseName": "internal_name",
			"type": "string"
		},
		{
			"name": "version",
			"baseName": "version",
			"type": "string"
		},
		{
			"name": "inputParamDefs",
			"baseName": "input_param_defs",
			"type": "Array<AppModelParameterDefinition>"
		},
		{
			"name": "outputParamDefs",
			"baseName": "output_param_defs",
			"type": "Array<AppModelParameterDefinition>"
		},
		{
			"name": "state",
			"baseName": "state",
			"type": "string"
		},
		{
			"name": "links",
			"baseName": "links",
			"type": "{ [key: string]: string; }"
		}];

	static getAttributeTypeMap() {
		return AppModel.attributeTypeMap;
	}
}

export class AppModelParameterDefinition {
	'name'?: string;
	'type'?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
		{
			"name": "name",
			"baseName": "name",
			"type": "string"
		},
		{
			"name": "type",
			"baseName": "type",
			"type": "string"
		}];

	static getAttributeTypeMap() {
		return AppModelParameterDefinition.attributeTypeMap;
	}
}

export class TokenModel {
	'tokenType'?: string;
	'accessToken'?: string;
	'expiresIn'?: number;
	'expiresOn'?: number;
	'tokenId'?: string;
	'namespace'?: string;

	static discriminator: string | undefined = undefined;

	static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
		{
			"name": "tokenType",
			"baseName": "token_type",
			"type": "string"
		},
		{
			"name": "accessToken",
			"baseName": "access_token",
			"type": "string"
		},
		{
			"name": "expiresIn",
			"baseName": "expires_in",
			"type": "number"
		},
		{
			"name": "expiresOn",
			"baseName": "expires_on",
			"type": "number"
		},
		{
			"name": "tokenId",
			"baseName": "token_id",
			"type": "string"
		},
		{
			"name": "namespace",
			"baseName": "namespace",
			"type": "string"
		}];

	static getAttributeTypeMap() {
		return TokenModel.attributeTypeMap;
	}
}


let enumsMap: { [index: string]: any } = {
}

let typeMap: { [index: string]: any } = {
	"AppModel": AppModel,
	"AppModelParameterDefinition": AppModelParameterDefinition,
	"TokenModel": TokenModel,
}

export interface Authentication {
	/**
	* Apply authentication settings to header and query params.
	*/
	applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
	public username: string = '';
	public password: string = '';

	applyToRequest(requestOptions: localVarRequest.Options): void {
		requestOptions.auth = {
			username: this.username, password: this.password
		}
	}
}

export class ApiKeyAuth implements Authentication {
	public apiKey: string = '';

	constructor(private location: string, private paramName: string) {
	}

	applyToRequest(requestOptions: localVarRequest.Options): void {
		if (this.location == "query") {
			(<any>requestOptions.qs)[this.paramName] = this.apiKey;
		} else if (this.location == "header" && requestOptions && requestOptions.headers) {
			requestOptions.headers[this.paramName] = this.apiKey;
		}
	}
}

export class OAuth implements Authentication {
	public accessToken: string = '';

	applyToRequest(requestOptions: localVarRequest.Options): void {
		if (requestOptions && requestOptions.headers) {
			requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
		}
	}
}

export class VoidAuth implements Authentication {
	public username: string = '';
	public password: string = '';

	applyToRequest(_: localVarRequest.Options): void {
		// Do nothing
	}
}

export enum AppRouterApiApiKeys {
}

export class AppRouterApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		'default': <Authentication>new VoidAuth(),
		'auth': new HttpBasicAuth(),
	}

	constructor(basePath?: string);
	constructor(username: string, password: string, basePath?: string);
	constructor(basePathOrUsername: string, password?: string, basePath?: string) {
		if (password) {
			this.username = basePathOrUsername;
			this.password = password
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: AppRouterApiApiKeys, value: string) {
		(this.authentications as any)[AppRouterApiApiKeys[key]].apiKey = value;
	}
	set username(username: string) {
		this.authentications.auth.username = username;
	}

	set password(password: string) {
		this.authentications.auth.password = password;
	}
	/**
	*
	* @summary ApiV1AppByNameAndVersion_DELETE
	* @param name
	* @param version
	* @param {*} [options] Override http request options.
	*/
	public apiV1AppByNameAndVersionDelete(name: string, version: string, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/api/v1/app/{name}/{version}'
			.replace('{' + 'name' + '}', encodeURIComponent(String(name)))
			.replace('{' + 'version' + '}', encodeURIComponent(String(version)));
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		// verify required parameter 'name' is not null or undefined
		if (name === null || name === undefined) {
			throw new Error('Required parameter name was null or undefined when calling apiV1AppByNameAndVersionDelete.');
		}

		// verify required parameter 'version' is not null or undefined
		if (version === null || version === undefined) {
			throw new Error('Required parameter version was null or undefined when calling apiV1AppByNameAndVersionDelete.');
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'DELETE',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary GetAppByNameVersion
	* @param name
	* @param version
	* @param {*} [options] Override http request options.
	*/
	public apiV1AppByNameAndVersionGet(name: string, version: string, options: any = {}): Promise<{ response: http.IncomingMessage; body: AppModel; }> {
		const localVarPath = this.basePath + '/api/v1/app/{name}/{version}'
			.replace('{' + 'name' + '}', encodeURIComponent(String(name)))
			.replace('{' + 'version' + '}', encodeURIComponent(String(version)));
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		// verify required parameter 'name' is not null or undefined
		if (name === null || name === undefined) {
			throw new Error('Required parameter name was null or undefined when calling apiV1AppByNameAndVersionGet.');
		}

		// verify required parameter 'version' is not null or undefined
		if (version === null || version === undefined) {
			throw new Error('Required parameter version was null or undefined when calling apiV1AppByNameAndVersionGet.');
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'GET',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: AppModel; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(body, "AppModel");
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary ApiV1AppByName_GET
	* @param name
	* @param {*} [options] Override http request options.
	*/
	public apiV1AppByNameGet(name: string, options: any = {}): Promise<{ response: http.IncomingMessage; body: Array<AppModel>; }> {
		const localVarPath = this.basePath + '/api/v1/app/{name}'
			.replace('{' + 'name' + '}', encodeURIComponent(String(name)));
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		// verify required parameter 'name' is not null or undefined
		if (name === null || name === undefined) {
			throw new Error('Required parameter name was null or undefined when calling apiV1AppByNameGet.');
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'GET',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: Array<AppModel>; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(body, "Array<AppModel>");
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary ApiV1App_GET
	* @param {*} [options] Override http request options.
	*/
	public apiV1AppGet(options: any = {}): Promise<{ response: http.IncomingMessage; body: Array<AppModel>; }> {
		const localVarPath = this.basePath + '/api/v1/app';
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'GET',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: Array<AppModel>; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(body, "Array<AppModel>");
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary UpdateApp
	* @param spec
	* @param _package
	* @param {*} [options] Override http request options.
	*/
	public apiV1AppPatch(spec?: Buffer, _package?: Buffer, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/api/v1/app';
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		if (spec !== undefined) {
			localVarFormParams['Spec'] = spec;
		}
		localVarUseFormData = true;

		if (_package !== undefined) {
			localVarFormParams['Package'] = _package;
		}
		localVarUseFormData = true;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'PATCH',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary CreateApp
	* @param spec
	* @param _package
	* @param {*} [options] Override http request options.
	*/
	public apiV1AppPost(spec?: Buffer, _package?: Buffer, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/api/v1/app';
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		if (spec !== undefined) {
			localVarFormParams['Spec'] = spec;
		}
		localVarUseFormData = true;

		if (_package !== undefined) {
			localVarFormParams['Package'] = _package;
		}
		localVarUseFormData = true;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'POST',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary GetAppSwagger
	* @param name
	* @param version
	* @param {*} [options] Override http request options.
	*/
	public apiV1AppSwaggerJsonByNameAndVersionGet(name: string, version: string, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/api/v1/app/{name}/{version}/swagger.json'
			.replace('{' + 'name' + '}', encodeURIComponent(String(name)))
			.replace('{' + 'version' + '}', encodeURIComponent(String(version)));
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		// verify required parameter 'name' is not null or undefined
		if (name === null || name === undefined) {
			throw new Error('Required parameter name was null or undefined when calling apiV1AppSwaggerJsonByNameAndVersionGet.');
		}

		// verify required parameter 'version' is not null or undefined
		if (version === null || version === undefined) {
			throw new Error('Required parameter version was null or undefined when calling apiV1AppSwaggerJsonByNameAndVersionGet.');
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'GET',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
}
export enum FileRouterApiApiKeys {
}

export class FileRouterApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		'default': <Authentication>new VoidAuth(),
		'auth': new HttpBasicAuth(),
	}

	constructor(basePath?: string);
	constructor(username: string, password: string, basePath?: string);
	constructor(basePathOrUsername: string, password?: string, basePath?: string) {
		if (password) {
			this.username = basePathOrUsername;
			this.password = password
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: FileRouterApiApiKeys, value: string) {
		(this.authentications as any)[FileRouterApiApiKeys[key]].apiKey = value;
	}
	set username(username: string) {
		this.authentications.auth.username = username;
	}

	set password(password: string) {
		this.authentications.auth.password = password;
	}
	/**
	*
	* @summary ApiV1FilesByFilePath_GET
	* @param filePath
	* @param {*} [options] Override http request options.
	*/
	public apiV1FilesByFilePathGet(filePath: string, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/api/v1/files/{filePath}'
			.replace('{' + 'filePath' + '}', encodeURIComponent(String(filePath)));
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		// verify required parameter 'filePath' is not null or undefined
		if (filePath === null || filePath === undefined) {
			throw new Error('Required parameter filePath was null or undefined when calling apiV1FilesByFilePathGet.');
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'GET',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary ApiV1FilesFilelistByPodName_GET
	* @param podName
	* @param containerName
	* @param {*} [options] Override http request options.
	*/
	public apiV1FilesFilelistByPodNameAndContainerNameGet(podName: string, containerName: string, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/api/v1/files/filelist/{podName}/{containerName}'
			.replace('{' + 'podName' + '}', encodeURIComponent(String(podName)))
			.replace('{' + 'containerName' + '}', encodeURIComponent(String(containerName)));
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		// verify required parameter 'podName' is not null or undefined
		if (podName === null || podName === undefined) {
			throw new Error('Required parameter podName was null or undefined when calling apiV1FilesFilelistByPodNameAndContainerNameGet.');
		}

		// verify required parameter 'containerName' is not null or undefined
		if (containerName === null || containerName === undefined) {
			throw new Error('Required parameter containerName was null or undefined when calling apiV1FilesFilelistByPodNameAndContainerNameGet.');
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'GET',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary FilesByFilePath_GET
	* @param filePath
	* @param {*} [options] Override http request options.
	*/
	public filesByFilePathGet(filePath: string, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/files/{filePath}'
			.replace('{' + 'filePath' + '}', encodeURIComponent(String(filePath)));
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		// verify required parameter 'filePath' is not null or undefined
		if (filePath === null || filePath === undefined) {
			throw new Error('Required parameter filePath was null or undefined when calling filesByFilePathGet.');
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'GET',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary FilesFilelistByPodNameAndContainerName_GET
	* @param podName
	* @param containerName
	* @param {*} [options] Override http request options.
	*/
	public filesFilelistByPodNameAndContainerNameGet(podName: string, containerName: string, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/files/filelist/{podName}/{containerName}'
			.replace('{' + 'podName' + '}', encodeURIComponent(String(podName)))
			.replace('{' + 'containerName' + '}', encodeURIComponent(String(containerName)));
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		// verify required parameter 'podName' is not null or undefined
		if (podName === null || podName === undefined) {
			throw new Error('Required parameter podName was null or undefined when calling filesFilelistByPodNameAndContainerNameGet.');
		}

		// verify required parameter 'containerName' is not null or undefined
		if (containerName === null || containerName === undefined) {
			throw new Error('Required parameter containerName was null or undefined when calling filesFilelistByPodNameAndContainerNameGet.');
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'GET',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
}
export enum HealthRouterApiApiKeys {
}

export class HealthRouterApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		'default': <Authentication>new VoidAuth(),
		'auth': new HttpBasicAuth(),
	}

	constructor(basePath?: string);
	constructor(username: string, password: string, basePath?: string);
	constructor(basePathOrUsername: string, password?: string, basePath?: string) {
		if (password) {
			this.username = basePathOrUsername;
			this.password = password
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: HealthRouterApiApiKeys, value: string) {
		(this.authentications as any)[HealthRouterApiApiKeys[key]].apiKey = value;
	}
	set username(username: string) {
		this.authentications.auth.username = username;
	}

	set password(password: string) {
		this.authentications.auth.password = password;
	}
	/**
	*
	* @summary ApiV1Health_GET
	* @param query
	* @param {*} [options] Override http request options.
	*/
	public apiV1HealthGet(query?: string, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/api/v1/health';
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		if (query !== undefined) {
			localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'GET',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary ApiV1Health_POST
	* @param {*} [options] Override http request options.
	*/
	public apiV1HealthPost(options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/api/v1/health';
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'POST',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary Health_GET
	* @param query
	* @param {*} [options] Override http request options.
	*/
	public healthGet(query?: string, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/health';
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		if (query !== undefined) {
			localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
		}

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'GET',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary Health_POST
	* @param {*} [options] Override http request options.
	*/
	public healthPost(options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
		const localVarPath = this.basePath + '/health';
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'POST',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
}
export enum TokenRouterApiApiKeys {
}

export class TokenRouterApi {
	protected _basePath = defaultBasePath;
	protected defaultHeaders: any = {};
	protected _useQuerystring: boolean = false;

	protected authentications = {
		'default': <Authentication>new VoidAuth(),
		'auth': new HttpBasicAuth(),
	}

	constructor(basePath?: string);
	constructor(username: string, password: string, basePath?: string);
	constructor(basePathOrUsername: string, password?: string, basePath?: string) {
		if (password) {
			this.username = basePathOrUsername;
			this.password = password
			if (basePath) {
				this.basePath = basePath;
			}
		} else {
			if (basePathOrUsername) {
				this.basePath = basePathOrUsername
			}
		}
	}

	set useQuerystring(value: boolean) {
		this._useQuerystring = value;
	}

	set basePath(basePath: string) {
		this._basePath = basePath;
	}

	get basePath() {
		return this._basePath;
	}

	public setDefaultAuthentication(auth: Authentication) {
		this.authentications.default = auth;
	}

	public setApiKey(key: TokenRouterApiApiKeys, value: string) {
		(this.authentications as any)[TokenRouterApiApiKeys[key]].apiKey = value;
	}
	set username(username: string) {
		this.authentications.auth.username = username;
	}

	set password(password: string) {
		this.authentications.auth.password = password;
	}
	/**
	*
	* @summary ApiV1Token_POST
	* @param {*} [options] Override http request options.
	*/
	public apiV1TokenPost(options: any = {}): Promise<{ response: http.IncomingMessage; body: TokenModel; }> {
		const localVarPath = this.basePath + '/api/v1/token';
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'POST',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: TokenModel; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(body, "TokenModel");
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
	/**
	*
	* @summary Token_POST
	* @param {*} [options] Override http request options.
	*/
	public tokenPost(options: any = {}): Promise<{ response: http.IncomingMessage; body: TokenModel; }> {
		const localVarPath = this.basePath + '/token';
		let localVarQueryParameters: any = {};
		let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
		let localVarFormParams: any = {};

		(<any>Object).assign(localVarHeaderParams, options.headers);

		let localVarUseFormData = false;

		let localVarRequestOptions: localVarRequest.Options = {
			method: 'POST',
			qs: localVarQueryParameters,
			headers: localVarHeaderParams,
			uri: localVarPath,
			useQuerystring: this._useQuerystring,
			json: true,
		};

		this.authentications.auth.applyToRequest(localVarRequestOptions);

		this.authentications.default.applyToRequest(localVarRequestOptions);

		if (Object.keys(localVarFormParams).length) {
			if (localVarUseFormData) {
				(<any>localVarRequestOptions).formData = localVarFormParams;
			} else {
				localVarRequestOptions.form = localVarFormParams;
			}
		}
		return new Promise<{ response: http.IncomingMessage; body: TokenModel; }>((resolve, reject) => {
			localVarRequest(localVarRequestOptions, (error, response, body) => {
				if (error) {
					reject(error);
				} else {
					body = ObjectSerializer.deserialize(body, "TokenModel");
					if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
						resolve({ response: response, body: body });
					} else {
						reject({ response: response, body: body });
					}
				}
			});
		});
	}
}
